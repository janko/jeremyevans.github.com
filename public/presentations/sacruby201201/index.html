<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Quinto and Coffeescript/NodeJS</title>

  <meta name="viewport" content="width=device-width"/>

  <link rel="stylesheet" href="./css/reset.css" type="text/css"/>
  <link rel="stylesheet" href="./css/showoff.css" type="text/css"/>

  <script type="text/javascript" src="./js/jquery-1.4.2.min.js"></script>
  <script type="text/javascript" src="./js/jquery.cycle.all.js"></script>
	<script type="text/javascript" src="./js/jquery-print.js"></script>
  <script type="text/javascript" src="./js/jquery.batchImageLoad.js"></script>

  <script type="text/javascript" src="./js/jquery.doubletap-0.1.js"></script>

  <script type="text/javascript" src="./js/fg.menu.js"></script>
  <script type="text/javascript" src="./js/showoff.js"></script>
  <script type="text/javascript" src="./js/jTypeWriter.js"> </script>
  <script type="text/javascript" src="./js/sh_main.min.js"></script>
  <script type="text/javascript" src="./js/core.js"></script>
  <script type="text/javascript" src="./js/showoffcore.js"></script>
  <script type="text/javascript" src="./js/coffee-script.js"></script>

  <link type="text/css" href="./css/fg.menu.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/theme/ui.all.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/sh_style.css" rel="stylesheet" >

  
    <link rel="stylesheet" href="file/something.css" type="text/css"/>
  

  

  <script type="text/javascript">
  $(function(){
      setupPreso(false, './');
  });
  </script>

</head>

<body>

<a tabindex="0" href="#search-engines" class="fg-button fg-button-icon-right ui-widget ui-state-default ui-corner-all" id="navmenu"><span class="ui-icon ui-icon-triangle-1-s"></span>slides</a>
<div id="navigation" class="hidden"></div>

<div id="help">
  <table>
    <tr><td class="key">z, ?</td><td>toggle help (this)</td></tr>
    <tr><td class="key">space, &rarr;</td><td>next slide</td></tr>
    <tr><td class="key">shift-space, &larr;</td><td>previous slide</td></tr>
    <tr><td class="key">d</td><td>toggle debug mode</td></tr>
    <tr><td class="key">## &lt;ret&gt;</td><td>go to slide #</td></tr>
    <tr><td class="key">c, t</td><td>table of contents (vi)</td></tr>
    <tr><td class="key">f</td><td>toggle footer</td></tr>
    <tr><td class="key">r</td><td>reload slides</td></tr>
    <tr><td class="key">n</td><td>toggle notes</td></tr>
    <tr><td class="key">p</td><td>run preshow</td></tr>
  </table>
</div>

<div class="buttonNav">
  <input type="submit" onClick="prevStep();" value="prev"/>
  <input type="submit" onClick="nextStep();" value="next"/>
</div>

<div id="preso">loading presentation...</div>
<div id="footer">
  <span id="slideInfo"></span>
  <span id="debugInfo"></span>
  <span id="notesInfo"></span>
</div>

<div id="slides" class="offscreen" style="display:none;">
<div class="slide" data-transition="none"><div class="content center" ref="intro/slides/1">
<p class="notes">Hi everybody.  Tonight I'm going to be talking about Quinto, a old board game that I've been developing on an online version of using Coffeescript and NodeJS with the Express web framework.</p>

<h1>Quinto and Coffeescript/NodeJS</h1>

<h2>Jeremy Evans</h2>

<h3>Sacramento Ruby Meetup</h3>

<h3>January 2012</h3></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="intro/slides/2">
<p class="notes">This presentation is going to have 3 main parts.  First is a discussion of Quinto the game.  Second is some pros and cons I've found when developing with Coffeescript compared to Javascript.  Third is some pros and cons of developing with NodeJS and Express compared to Ruby and Sinatra or Rails.</p>

<h1>Overview</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/1">
<h1>Quinto</h1>

<p class="notes">Quinto is an old 3M board game that was released in the mid 1960's.  There's not a lot of information about it online.  I only know about it because I came across it in a thrift store and bought it for a few dollars.  The simplest description of it is it is Scrabble with numbers and sums instead of letters and words.</p></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/2">
<p class="notes">Quinto is played on a 17x17 square board.</p>

<h1>Board</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/3">
<p class="notes">Each game is played with 90 tiles, with values on the tiles from 1 to 10.</p>

<h1>Tiles</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/4">
<p class="notes">There are only a few rules in Quinto.</p>

<h1>Rules</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/5">
<p class="notes">The main rule is that each horizontal or vertical consecutive run of tiles must have the sum of the tiles equal a multiple of 5.</p>

<h1>Sum to Multiple of 5</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/6">
<p class="notes">The secondary rule is that no more than 5 tiles may be placed consecutively.</p>

<h1>No More Than 5 Consecutive Tiles</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/7">
<p class="notes">The first move must include a tile in the center square.</p>

<h1>First Player Must Play in Center Square</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/8">
<p class="notes">All following moves must include a tile that is played adjacent to an existing tile.</p>

<h1>All Following Moves Must Have a Tile Adjacent to an Existing Tile</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/9">
<p class="notes">At any point, you can pass instead of making a move.</p>

<h1>Passing</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/10">
<p class="notes">Scoring is like Scrabble, in that you add the sums of all runs you have made or extended.</p>

<h1>Scoring</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/11">
<p class="notes">The game ends when there are no remaining tiles and one player is out of tiles in their rack.</p>

<h1>End Game</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/12">
<p class="notes">Let's try a quick demo</p>

<h1>Demo</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/13">
<p class="notes">The app is designed with 4 main parts: game logic, server logic, persistence logic, and client logic, all pure coffeescript files</p>

<h1>Design</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/14">
<p class="notes">I originally started developing the game as a command line program, so I worked on the game logic first.</p>

<h1>quinto.coffee - Game Logic</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/15">
<p class="notes">My main design choice was to model the game as a sequence of states, with the last state being the current state of the game.  This makes it so you don't have to worry about overwriting any information, on a move or pass, you just append the new state to the list of game states.</p>

<h1>Main Datastructure - GameState</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/16">
<p class="notes">The server logic is just a bunch of routes that you can get or post to, and it's not very interesting.  It's mostly gluing the game logic to the persistence logic and running commands based on user input.</p>

<h1>app.coffee - Server Logic</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/17">
<p class="notes">I'm planning to enable multiple persistence schemes.  I chose to do the simplest first, which is a simple directory tree of JSON files.  PostgreSQL support is planned next, to make it easy to host on Heroku.</p>

<h1>persist_json.coffee - Persistence Logic</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/18">
<p class="notes">All client logic is in client.coffee.  Quinto is designed as a single-page application.  When the server starts up, it precompiles the quinto.coffee and client.coffee files into a single javascript file which is referenced in the index.html page.</p>

<h1>client.coffee - Client Logic</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/19">
<p class="notes">As you saw in the demo, signup uses a password.  We are using bcrypt password hashing, which is much more secure than using a standard cryptographic hash like sha1.</p>

<h1>Password Security - bcrypt</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/20">
<p class="notes">What probably wasn't obvious in the demo is that we are not using sessions or cookies.  After logging in, each user is provided an API token, which they must send with all requests.  Currently, the token is per user, but it could easily be made per user and per game later.  This basically eliminates CSRF attacks.</p>

<h1>Request Security - API tokens</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/21">
<p class="notes">Other than the initial html page, all server responses are a JSON array.  Each entry in the array is an object with an action entry, describing the action to take.  The client just does a loop over this array, with each action calling a method.</p>

<h1>Data Transfer - JSON</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/22">
<p class="notes">Currently, the client does simple old fashioned polling every 10 seconds for new data if it is not their turn.  That could be switched to long polling or websockets in the future.</p>

<h1>Event Handling - Polling</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/23">
<p class="notes">Most of the action handler methods just use standard JQuery for the DOM updates, though JQueryUI is also used for drag-drop.</p>

<h1>DOM Updates - JQuery</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="quinto/slides/24">
<p class="notes">Any questions about Quinto before I move on?</p>

<h1>Questions</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/1">
<p class="notes">The rest of the presentation is going to be my general thoughts on Coffeescript and NodeJS.  Cavaet Audiens is Latin for "Let the listener beware".  I only have a few weeks of experience in using Coffeescript/NodeJS, so anything I say could be way off base.</p>

<h1>Cavaet Audiens</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/2">
<p class="notes">I originally was going to give a single list of pros and cons, but I think that conflates two separate issues.  The first issue is comparing coffeescript to javascript.</p>

<h1>Coffeescript vs. Javascript</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/3">
<p class="notes">Let's start off with the pros. Coffeescript has a much nicer syntax than javascript, borrowing from both ruby and python.  Unless you hate the idea of signficant indentation, you'll probably like Coffeescript syntax better.  I used python before ruby, so it doesn't bother me.</p>

<h1>Pros - Syntax</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/4">
<p class="notes">Some nicities are using @ to refer to this.</p>

<h1>@</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/5">
<p class="notes">The -&gt; and =&gt; define functions.  The difference is that the =&gt; changes @ to bind to the current value of this.  This is sort of a con as it can get a little confusing, but it's needed in a lot of async code.</p>

<h1>-&gt;, =&gt;</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/6">
<p class="notes">One of the biggest gains is not having to worry about using var for all variables and accidentally creating global variables.</p>

<h1>No var</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/7">
<p class="notes">Another niceity is list comprehensions, which work similar to the ones in python and simplify array processing.</p>

<h1>List comprehensions</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/8">
<p class="notes">Finally, another big gain is that everything is an expression, similar to ruby.</p>

<h1>Everything is an expression</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/9">
<p class="notes">The main downside of Coffeescript is debugging code.</p>

<h1>Cons - Debugging</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/10">
<p class="notes">Backtraces in coffeescript code have javascript line information, instead of coffeescript line information, making them mostly useless.</p>

<h1>Backtraces That Suck</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/11">
<p class="notes">You will pretty much have to read the compiled javascript in many cases to figure out your error.  This is fairly easy if you are precompiling the coffeescript to serve to a browser (since Firebug/Chrome Inspector tools show the compiled output).  However, for debugging server code, it usually requires a separate compilation step.</p>

<h1>Hope You Like Reading Compiled Javascript</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="coffeescript/slides/12">
<p class="notes">I think the syntax improvements outweigh the debugging pain, so I'd definitely use Coffeescript over Javascript in the future.</p>

<h1>Verdict</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/1">
<p class="notes">Like Coffeescript vs. Javascript, the choice to use NodeJS and Express compared to Ruby and Sinatra or Rails has some pros and cons.</p>

<h1>NodeJS/Express vs. Ruby/Sinatra|Rails</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/2">
<p class="notes">In general, NodeJS is faster than ruby, and will probably scale farther on the same hardware.</p>

<h1>Pro - Faster</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/3">
<p class="notes">However, that's the smaller of the two main benefits.  The primary benefit is you can share code on the client and the server.  This is a huge benefit, since otherwise you might have to write the same or similar code twice.  In Quinto, it was important that the client have all of the game logic, so you could get an immediate response when planning moves.</p>

<h1>Pro - Sharing Code</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/4">
<p class="notes">- The biggest problem with NodeJS/Express is that you have to write everything in an async manner using nested callback functions, as NodeJS's synchronous IO functions block the entire process.  This is incredibly painful, and I'll later conclude it is unnecessary.  First, let me enumerate some problems.</p>

<h1>Con - Async</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/5">
<p class="notes">With async code, you can't use throw for error handling.  In fact, if you throw an exception in an async function on Express, it kills the server immediately.</p>

<h1>Error Handling</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/6">
<p class="notes">To work around this, you have to thread the Express error handling function all the way to the lowest levels of the stack.</p>

<h1>Thread Error Handling Function to the Lowest Levels</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/7">
<p class="notes">Because all potentially blocking calls need to take a callback function, you can't really mix IO code freely with Non-IO code.</p>

<h1>Can't Mix IO Code and Non-IO Code</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/8">
<p class="notes">One example of this is that you can't call IO functions in loops, you need to use recursion instead.</p>

<h1>Can't Use IO Functions within Loops</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/9">
<p class="notes">The inability to mix IO and non-IO code is similar to haskell, but without the benefits that haskell gives you like an IO monad that lets you write synchronous-style code.</p>

<h1>The Pain of Haskell minus the Benefits of Haskell</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/10">
<p class="notes">Your NodeJS async code ends up looking like stair steps, since each IO method takes a separate nested callback.</p>

<h1>Stair Stepping Code</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/11">
<p class="notes">The fundemental problem with NodeJS's design is that it conflates async with nonblocking.  It would be much better if synchronous functions didn't block the whole process, instead just blocking the current coroutine/thread.</p>

<h1>Why Should Synchronous Functions Block the Entire Process?</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/12">
<p class="notes">Basically, the synchronous functions should behave like the asynchronous functions, but instead of storing a callback function, it should store a continuation of the current state, so that when the IO completes, control returns to the caller of the function.</p>

<h1>Store a Continuation Instead of a Callback Function</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/13">
<p class="notes">The reason most thread-based implementations are slow is mostly because they are preemptive instead of cooperative.  Preemative handles worse case scenarios better, but is not good for high-performance.  However, a cooperative thread approach can be as performant as an async approach, without the pain.</p>

<h1>OMG, I Just Described Cooperative Threading</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/14">
<p class="notes">Computer science research done way back in the 70s by Lauer and Needham showed that threads and events are mathematically equivalent.</p>

<h1>Truth: Threads and Events are Mathematically Equivalent</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/15">
<p class="notes">At the Usenix Conference in 2003, Rob von Behren, Jeremy Condit, and Eric Brewer presented a paper called "Why Events are a Bad Idea".</p>

<h1>"Why Events are a Bad Idea"</h1></div>
</div><div class="slide" data-transition="none"><div class="content" ref="nodejs/slides/16">
<p class="notes">The paper describes the problems that event-based systems have, and how those problems can be basically fixed by using cooperative threading uses continuations.</p>

<pre><code> As a case in point, the cooperative task
 management technique described by [...]
 allows users of an event system to write
 thread-like code that gets transformed
 into continuations around blocking calls.
 In many cases, fixing the problems with
 events is tantamount to switching to
 threads.
</code></pre></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/17">
<p class="notes">The real truth is that async code is only needed when you want something running in parallel.  Async code certainly requires nonblocking code, but nonblocking code should not require async code.</p>

<h1>Truth: Async is for Parallel Code</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/18">
<p class="notes">I'm guessing that almost all NodeJS async use is for nested callbacks executed in serial, and not for true parallel code.</p>

<h1>Guess: Most NodeJS Async Uses are Serial, not Parallel</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/19">
<p class="notes">The real object oriented way to handle parallel async code is to return a future.  A future is an object that does the async processing in the background or when accessed, and becomes the result of the async computation when the async code returns.</p>

<h1>OO Parallel Async Code -&gt; Futures</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/20">
<p class="notes">In ruby, you can do this with lazy.rb or the promise gem, but it probably doesn't perform that well as it is implemented with ruby threads.</p>

<h1>lazy.rb / Promise</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/21">
<p class="notes">Using a language with built in futures would probably be better, and Clojure, IO, and Racket all have support built in.</p>

<h1>Clojure/Io/Racket</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="nodejs/slides/22">
<p class="notes">It's hard to say.  Even for a simple application like Quinto, the async stuff is a real pain, so I assume it's only worse in larger applications.  I probably would only use NodeJS in the future if I had a real need for sharing code between the client and server.</p>

<h1>Verdict</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="conclusion/slides/1">
<p class="notes">Any final questions about coffeescript, NodeJS, Express, or Quinto?</p>

<h1>Questions?</h1></div>
</div><div class="slide" data-transition="none"><div class="content center" ref="conclusion/slides/2">
<p class="notes">Thank you very much for letting me present tonight.  I'll be posting the code for quinto and this presentation on GitHub, and probably tweeting about it tomorrow.</p>

<h1>Thank You!</h1>

<h2>twitter.com/jeremyevans0</h2>

<h2>github.com/jeremyevans</h2></div>
</div></div>

</body>
</html>
