<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Optimization Techniques Used by the Benchmark Winners</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>

  <link rel="stylesheet" href="./css/reset.css" type="text/css"/>

  <link type="text/css" href="./css/fg.menu.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/theme/ui.all.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/sh_style.css" rel="stylesheet" />
  <link type="text/css" href="./css/tipsy.css" rel="stylesheet" />

  <link rel="stylesheet" href="./css/showoff.css" type="text/css"/>

    <style type="text/css">
      @media screen {
        #preso, .slide {
          width: 1280px;
          height: 720px;
        }
        #footer { width: 1261px; }
      }
    </style>

  <script type="text/javascript" src="./js/jquery-1.4.2.min.js"></script>
  <script type="text/javascript" src="./js/jquery.cycle.all.js"></script>
	<script type="text/javascript" src="./js/jquery-print.js"></script>
  <script type="text/javascript" src="./js/jquery.batchImageLoad.js"></script>
  <script type="text/javascript" src="./js/jquery.parsequery.min.js"></script>
  <script type="text/javascript" src="./js/jquery.doubletap-0.1.js"></script>
  <script type="text/javascript" src="./js/jquery.tipsy.js"></script>

  <script type="text/javascript" src="./js/fg.menu.js"></script>
  <script type="text/javascript" src="./js/showoff.js"></script>
  <script type="text/javascript" src="./js/jTypeWriter.js"> </script>
  <script type="text/javascript" src="./js/sh_main.min.js"></script>
  <script type="text/javascript" src="./js/core.js"></script>
  <script type="text/javascript" src="./js/showoffcore.js"></script>
  <script type="text/javascript" src="./js/coffee-script.js"></script>

      <script type="text/javascript" src="./js/sh_lang/sh_ruby.min.js"></script>

    <link rel="stylesheet" href="./file/fonts.css" type="text/css"/>
    <link rel="stylesheet" href="./file/something.css" type="text/css"/>


  <script type="text/javascript">
  $(function(){
      if(!('slaveWindow' in window) && window.name !== 'toolbar' && $(window).width() < $(document).width()) {
        no_resize = true;
        $('body').css("zoom", ""+($(window).width()*100.0)/$(document).width()+"%");
        $('body').css("overflow-y", "auto");
        $('body').css("overflow-x", "hidden");
        $('#notesInfo').css("font-size", ""+$(document).width()*14.0/$(window).width()+"px");
        $('#notesInfo').css("line-height", ""+$(document).width()*20.0/$(window).width()+"px");
      }
      setupPreso(false, '.');
  });
  </script>

</head>

<body>

<div id="help">
  <table>
    <tr><td class="key">z, ?</td><td>toggle help (this)</td></tr>
    <tr><td class="key">space, &rarr;</td><td>next slide</td></tr>
    <tr><td class="key">shift-space, &larr;</td><td>previous slide</td></tr>
    <tr><td class="key">d</td><td>toggle debug mode</td></tr>
    <tr><td class="key">## &lt;ret&gt;</td><td>go to slide #</td></tr>
    <tr><td class="key">r</td><td>reload slides</td></tr>
    <tr><td class="key">n</td><td>toggle notes</td></tr>
  </table>
</div>

<div class="buttonNav">
  <input type="submit" onClick="prevStep();" value="prev"/>
  <input type="submit" onClick="nextStep();" value="next"/>
</div>

<div id="preso"><center>loading presentation...</center></div>
<div id="footer">
  <span id="notesInfo"></span>
  <img id="disconnected" src="/css/disconnected.png" />
</div>

<div id="slides" class="offscreen" style="display:none;">
<div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/1">

<div class="notes">
<p>Minyasan, konbanwa. RubyKaigi no saigo no kicho koen e yokoso. Sumimasen, watashi no nihongo chishiki wa kagira rete ori, eigo de tsudzukenakereba. (Good evening everyone. Welcome to the closing keynote of RubyKaigi. Apologies, my knowledge of Japanese is limited, and I must continue in English.)</p>
</div>

<p><img src="./file/rubykaigi.svg" style="position: absolute; top: 15px; left: 15px;"/>
<h1 class="red" style="font-size: 130px; position: absolute; top: 220px; left: 440px;">Closing</h1><h1 class="blue" style="font-size: 270px; position: absolute; top: 245px; left: 230px;">Keynote</h1></p>
</div>
</div><div id="slides/slides" class="slide " data-transition="none">
  <div class="content " ref="slides/slides/2">

<div class="notes">
<p>Today, I will be discussing some optimization techniques used in Sequel and Roda, providing some background on why these libraries are significantly faster than their alternatives, as shown in TechEmpower&#x2019;s independent benchmarks.</p>
</div>

<p><img src="./file/bench.png" style="position: absolute; top: 85px; left: 25px;"/>
<h1 class="blue" style="font-size: 85px; position: absolute; top: 0; right: 28px;">Optimization</h1><h1 class="blue" style="font-size: 80px; position: absolute; top: 75px; right: 25px;">Techniques</h1><h1 class="red" style="font-size: 60px; position: absolute; top: 150px; right: 125px;">Used by the</h1><h1 class="blue" style="font-size: 85px; position: absolute; top: 200px; right: 20px;">Benchmark</h1><h1 class="blue" style="font-size: 85px; position: absolute; top: 280px; right: 20px;">Winners</h1>
<p><img src="./file/rubykaigi.svg" style="position: absolute; top: 500px; right: 30px; width: 450px; height: 115px;"/>
</p>
</p>
</div>
</div><div id="slides/slides" class="slide " data-transition="none">
  <div class="content " ref="slides/slides/3">

<div class="notes">
<p>TechEmpower has been benchmarking web frameworks in many languages since 2013. They have been benchmarking Rails and Sinatra since the beginning. In 2017, they started benchmarking Sequel with Roda, and since then, the combination of Sequel and Roda has been leading TechEmpower&#x2019;s benchmarks of Ruby web frameworks.</p>
</div>

<p><img src="./file/bench.png" style="position: absolute; top: 85px; left: 25px;"/>

<p><img src="./file/techempower.svg" style="width: 600px; height: 300px; position: absolute; top: 250px; left: 870px;"/>
</p>
</p>
</div>
</div><div id="slides/slides" class="slide " data-transition="none">
  <div class="content " ref="slides/slides/4">

<div class="notes">
<p>Sequel is a toolkit for database access in Ruby, and Roda is a toolkit for writing web applications in Ruby. While I am not the original author of either library, I have been maintaining both libraries for many years, and have added all of the optimizations I will be discussing today.</p>
</div>

<p><img src="./file/ruby-sequel.png" style="width: 600px; height: 300px; position: absolute; top: 60px; left: 340px;"/>

<p><img src="./file/roda-logo.svg" style="width: 600px; height: 300px; position: absolute; bottom: 60px; left: 340px;"/>
</p>
</p>
</div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/5">

<div class="notes">
<p>My name is Jeremy Evans. I started writing Ruby libraries in 2005, and started contributing to Ruby development in 2009.|My day job has me responsible for managing all information technology operations for a small government department. Part of that job is maintaining applications of all sizes written in Ruby using Sequel and Roda.</p>
</div>

<p><img class="profile-pic" src="./file/jeremy.jpg" style="position: absolute; top: 100px; left: 80px;"/>
<h1 class="red" style="font-size: 60px; position: absolute; top: 300px; left: 500px;">GitHub: <span class="blue mono">jeremyevans</span>
</h1><h1 class="red" style="font-size: 60px; position: absolute; top: 375px; left: 500px;">Twitter: <span class="blue mono">@jeremyevans0</span>
</h1></p>
</div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/6">

<div class="notes">
<p>While I added the optimizations I am discussing today to Sequel and Roda, many of the optimizations I learned about from others. My experience is that it is easier to implement optimization approaches that other developers have created, compared to developing your own optimization approaches.</p>
</div>
<h1 class="red" style="font-size: 180px; position: absolute; top: 60px; left: 100px;">Standing</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 215px; left: 270px;">Upon</h1><h1 class="red" style="font-size: 260px; position: absolute; top: 290px; left: 50px;">Shoulders</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/7">

<div class="notes">
<p>With that in mind, the goal of this presentation is to demonstrate some optimization techniques, approaches, and principles that you can use to improve the performance of your own Ruby code, hopefully saving you time should you want to optimize your own libraries or applications.</p>
</div>
<h1 class="blue" style="font-size: 180px; position: absolute; top: 170px; left: 380px;">The</h1><h1 class="red" style="font-size: 280px; position: absolute; top: 240px; left: 200px;">Goal</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/8">

<div class="notes">
<p>The first optimization principle, is the fastest code is usually the code that does the least. If you want fast code, as much as possible, avoid unnecessary processing during performance sensitive code paths.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 120px; left: 220px;">Avoid</h1><h1 class="red" style="font-size: 180px; position: absolute; top: 200px; left: 100px;">Processing</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/9">

<div class="notes">
<p>An old Ruby web framework named Merb had a great motto related to this, No code is faster than no code. In other words, if you can get the same result without executing any code, any approach that requires executing code will be slower.|A major reason Sequel and Roda are faster than their alternatives is that they try to execute less code, at least by default.</p>
</div>
<blockquote style="margin-top: 150px; font-size: 80px;">
<p><span class="red">No Code</span> is Faster than<br><span class="red">No Code</span></br>
<p><span class="red">&#x2014;</span>Merb Motto</p>
</p></blockquote>
</div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/10">

<div class="notes">
<p>Here is the class method that Sequel uses to create new model objects.</p>
</div>
<pre class="sh_ruby" style="font-size: 45px; margin-top: 50px;"><code>def call(values)
  o = allocate
  o.instance_variable_set(:@values, values)
  o
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/11">

<div class="notes">
<p>The method name used is call, which is kind of an odd choice for a method that creates objects. I will discuss a little bit later why call is used as the method name, as that relates to a different optimization, but notice how this method does very little.</p>
</div>
<pre class="sh_ruby" style="font-size: 45px; margin-top: 50px;"><code>def <b>call</b>(values)
  o = allocate
  o.instance_variable_set(:@values, values)
  o
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/12">

<div class="notes">
<p>It takes the values hash that was retreived from the database.</p>
</div>
<pre class="sh_ruby" style="font-size: 45px; margin-top: 50px;"><code>def call(<b>values</b>)
  o = allocate
  o.instance_variable_set(:@values, values)
  o
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/13">

<div class="notes">
<p>It allocates a new model instance.</p>
</div>
<pre class="sh_ruby" style="font-size: 45px; margin-top: 50px;"><code>def call(values)
  <b>o = allocate</b>
  o.instance_variable_set(:@values, values)
  o
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/14">

<div class="notes">
<p>It sets the values hash to an instance variable.</p>
</div>
<pre class="sh_ruby" style="font-size: 45px; margin-top: 50px;"><code>def call(values)
  o = allocate
  <b>o.instance_variable_set(:@values, values)</b>
  o
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/15">

<div class="notes">
<p>Then it returns the instance.</p>
</div>
<pre class="sh_ruby" style="font-size: 45px; margin-top: 50px;"><code>def call(values)
  o = allocate
  o.instance_variable_set(:@values, values)
  <b>o</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/16">

<div class="notes">
<p>Here is a comparison with a similar instance method that ActiveRecord uses to create instances using hashes retreived from the database.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals








  @new_record = new_record
  @attributes = attributes

  self.class.define_attribute_methods


  yield self if block_given?

  _run_find_callbacks




  _run_initialize_callbacks





  self
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/17">

<div class="notes">
<p>And here are some comments showing what each of the called methods do.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record
  @attributes = attributes

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/18">

<div class="notes">
<p>When you compare these side to side, it should not be a surprise that Sequel is faster. Sequel does much less in this performance sensitive code path. So how is Sequel able to avoid executing most of this code? Let&#x2019;s go over the different sections in this method.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord                                                 # Sequel
def init_with_attributes(attributes, new_record = false)       <b>def call(values)</b>
  init_internals
  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record
  @attributes = attributes                                       <b>instance_variable_set(:@values, values)</b>

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end                                                            <b>end</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/19">

<div class="notes">
<p>Let&#x2019;s start with this code. ActiveRecord starts by initializing all of these instance variables, mostly to nil or false.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
<b class="block">  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record</b>
  @attributes = attributes

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 0px; border: 3px dotted #00005B; padding: 10px;"><code>@readonly                 = false
@destroyed                = false
@marked_for_destruction   = false
@destroyed_by_association = nil
@new_record               = true
@_start_transaction_state = {}
@transaction_state        = nil
@new_record = new_record
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/20">

<div class="notes">
<p>It does set new_record to true here.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
<b class="block">  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record</b>
  @attributes = attributes

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 0px; border: 3px dotted #00005B; padding: 10px;"><code>@readonly                 = false
@destroyed                = false
@marked_for_destruction   = false
@destroyed_by_association = nil
<b>@new_record               = true</b>
@_start_transaction_state = {}
@transaction_state        = nil
@new_record = new_record
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/21">

<div class="notes">
<p>But ends up setting new_record back to false here, because the method is usually called with only one argument, and the new_record local variable is the second argument, which defaults to false.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, <b>new_record = false</b>)
  init_internals
<b class="block">  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record</b>
  @attributes = attributes

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 0px; border: 3px dotted #00005B; padding: 10px;"><code>@readonly                 = false
@destroyed                = false
@marked_for_destruction   = false
@destroyed_by_association = nil
@new_record               = true
@_start_transaction_state = {}
@transaction_state        = nil
<b>@new_record = new_record</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/22">

<div class="notes">
<p>Probably the most controversial optimization technique that both Sequel and Roda use is that they both avoid initializing instance variables to nil or false.</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 60px; left: 250px;">Avoid</h1><h1 class="red mono" style="font-size: 150px; position: absolute; top: 320px; left: 200px;">@iv = nil</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/23">

<div class="notes">
<p>Assuming you have 6 instance variables, not initializing the instance variables to nil or false is about 150% faster. For both Sequel and Roda, this optimization improves performance by a few percentage points in real world benchmarks.</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 60px; left: 250px;">Avoid</h1><h1 class="red mono" style="font-size: 150px; position: absolute; top: 320px; left: 200px;">@iv = nil</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 500px; left: 300px;">
<span class="red" style="font-size: 150%;">150%</span> faster</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/24">

<div class="notes">
<p>The reason this optimization is controversial is that accessing an uninitialized instance variable generates a warning in verbose mode. This verbose mode warning slows down all instance variable access, even if all instance variables are initialized.</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 60px; left: 250px;">Avoid</h1><h1 class="red mono" style="font-size: 150px; position: absolute; top: 320px; left: 200px;">@iv = nil</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 500px; left: 240px;">
<span class="red">ruby -w</span> warnings</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/25">

<div class="notes">
<p>I submitted a patch to speed up instance variable access by about 10% by removing this warning if verbose mode was not enabled at compile time,</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 60px; left: 250px;">Avoid</h1><h1 class="red mono" style="font-size: 150px; position: absolute; top: 320px; left: 200px;">@iv = nil</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 500px; left: 270px;"><span class="red">patch</span></h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/26">

<div class="notes">
<p>but unfortunately that was not considered enough of an improvement to justify the backwards compatibility breakage.</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 60px; left: 250px;">Avoid</h1><h1 class="red mono" style="font-size: 150px; position: absolute; top: 320px; left: 200px;">@iv = nil</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 500px; left: 270px;">
<span class="red">patch</span> rejected</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/27">

<div class="notes">
<p>Getting back to our example, there is one instance variable that is set to a value that is not nil or false, and it is start_transaction_state. As you might expect, this instance variable is only used for transactions, so if you are just retrieving a model instance and not saving it, it is not necessary to set this during initialization. Setting it allocates an unnecessary hash, which hurts performance.|In similar cases, Sequel will usually delay allocating the instance variable until it is actually needed.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
<b class="block">  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record</b>
  @attributes = attributes

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 0px; border: 3px dotted #00005B; padding: 10px;"><code>@readonly                 = false
@destroyed                = false
@marked_for_destruction   = false
@destroyed_by_association = nil
@new_record               = true
<b>@_start_transaction_state = {}</b>
@transaction_state        = nil
@new_record = new_record
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/28">

<div class="notes">
<p>This is another general optimization principle. Unless there is a high probability you will need to execute something, it is best to delay execution until you are sure you will need it, otherwise you may be doing unnecessary work.</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 180px; left: 100px;">Delay</h1><h1 class="red" style="font-size: 150px; position: absolute; top: 410px; left: 75px;">Computation</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/29">

<div class="notes">
<p>After setting the instance variables, the ActiveRecord model instance then asks its class to define instance methods for all of the model&#x2019;s attributes. This needs to be called for the first instance retrieved, because ActiveRecord does not define the attribute methods until then.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record
  @attributes = attributes

<b class="block">  self.class.define_attribute_methods
  # return false if @attribute_methods_generated</b>

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 480px; font-size: 28px; margin-top: 200px; border: 3px dotted #00005B; padding: 10px;"><code>self.class.define_attribute_methods
return false if @attribute_methods_generated
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/30">

<div class="notes">
<p>After the first instance has been retrieved, this method just returns without doing anything, so asking the class to define the attribute methods is slowing down all model instance creation after the first record. Sequel avoids this performance issue.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record
  @attributes = attributes

<b class="block">  self.class.define_attribute_methods
  # return false if @attribute_methods_generated</b>

  yield self if block_given?

  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 480px; font-size: 28px; margin-top: 200px; border: 3px dotted #00005B; padding: 10px;"><code>self.class.define_attribute_methods
<b>return false if @attribute_methods_generated</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/31">

<div class="notes">
<p>Instead of waiting until a model instance is retreived to define the attribute methods, Sequel::Model defines the attribute methods when you create the class. That way all model instances can assume the attribute methods have already been created, and they don&#x2019;t need to ask the model class to create them, speeding up all model instance creation.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 100px;"><code>
class MyModel &lt; Sequel::Model
  # attribute methods already defined
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/32">

<div class="notes">
<p>This represents another general optimization principle. Any time you have code is called many times, see if there is a way that you can run that code once instead of many times. Once is better than many.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 220px; left: 70px;">Once</h1><h1 class="red" style="font-size: 350px; position: absolute; top: 120px; left: 500px;">&gt;</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 220px; left: 770px;">Many</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/33">

<div class="notes">
<p>In Big-O terms, O(1) is better than O(n).</p>
</div>
<h1 class="blue" style="font-size: 200px; position: absolute; top: 200px; left: 70px;">O(1)</h1><h1 class="red" style="font-size: 350px; position: absolute; top: 120px; left: 500px;">&gt;</h1><h1 class="blue" style="font-size: 200px; position: absolute; top: 200px; left: 770px;">O(n)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/34">

<div class="notes">
<p>Applied to web applications, this principle means that if you should prefer to run code during application initialization, before accepting requests, if it will allow you to save time while processing requests. When the application process starts, initialization only happens once, but the process may be handling millions of requests during its runtime.</p>
</div>
<h1 class="blue" style="font-size: 70px; position: absolute; top: 270px; left: 50px;">Initialization</h1><h1 class="red" style="font-size: 350px; position: absolute; top: 120px; left: 500px;">&gt;</h1><h1 class="blue" style="font-size: 70px; position: absolute; top: 270px; left: 770px;">Runtime</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/35">

<div class="notes">
<p>The last thing that ActiveRecord does during model instance creation is run the find and initialize hooks for the model instance. However, if the model does not have any find or initialize hooks, this slows down model instance creation. It would be best to only run this code for the models where you actually need to use find or initialize hooks.</p>
</div>
<pre class="sh_ruby" style="font-size: 15px; margin-top: 10px;"><code># ActiveRecord
def init_with_attributes(attributes, new_record = false)
  init_internals
  #@readonly                 = false
  #@destroyed                = false
  #@marked_for_destruction   = false
  #@destroyed_by_association = nil
  #@new_record               = true
  #@_start_transaction_state = {}
  #@transaction_state        = nil

  @new_record = new_record
  @attributes = attributes

  self.class.define_attribute_methods
  # return false if @attribute_methods_generated

  yield self if block_given?

<b class="block">  _run_find_callbacks
  #callbacks = __callbacks[:find]
  #unless callbacks.empty?
  #  # ...
  #end
  _run_initialize_callbacks
  #callbacks = __callbacks[:initialize]
  #unless callbacks.empty?
  #  # ...
  #end</b>

  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 480px; font-size: 32px; margin-top: 200px; border: 3px dotted #00005B; padding: 10px;"><code>_run_find_callbacks
callbacks = __callbacks[:find]
unless callbacks.empty?
  # ...
end
_run_initialize_callbacks
callbacks = __callbacks[:initialize]
unless callbacks.empty?
  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/36">

<div class="notes">
<p>Sequel avoids the need for all models to check for initialize hooks, by moving the initialize hook into a plugin.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
class MyModel &lt; Sequel::Model
  plugin :after_initialize
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/37">

<div class="notes">
<p>Sequel and Roda share the idea of doing the minimum work possible by default. However, they are still designed to solve the same problems you can solve with other frameworks. In order to be as fast as possible by default, but still be flexible enough to solve the same problems, both Sequel and Roda use similar plugin systems.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 60px; left: 300px;">Plugin</h1><h1 class="red" style="font-size: 180px; position: absolute; top: 160px; left: 200px;">Systems</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/38">

<div class="notes">
<p>Both Sequel&#x2019;s and Roda&#x2019;s plugin systems are designed around the same basic idea. Each has an empty base class with no class or instance methods.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 100px;"><code>class Sequel::Model


end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/39">

<div class="notes">
<p>The class is extended with a module for the default class methods,</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 100px;"><code>class Sequel::Model
  <b>extend Sequel::Model::ClassMethods</b>

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/40">

<div class="notes">
<p>and a module for the default instance methods is included in the class.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 100px;"><code>class Sequel::Model
  extend Sequel::Model::ClassMethods
  <b>include Sequel::Model::InstanceMethods</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/41">

<div class="notes">
<p>You use the plugin class method to load plugins. Each Sequel or Roda plugin can contain a class methods module and/or an instance methods module.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
class MyModel &lt; Sequel::Model
  <b>plugin :after_initialize</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/42">

<div class="notes">
<p>Loading the plugin extends the class with the plugin&#x2019;s class methods module.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
class MyModel &lt; Sequel::Model
  plugin :after_initialize
  # <b>extend AfterInitialize::ClassMethods</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/43">

<div class="notes">
<p>It also includes the plugin&#x2019;s instance methods module in the class.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
class MyModel &lt; Sequel::Model
  plugin :after_initialize
  # extend AfterInitialize::ClassMethods
  # <b>include AfterInitialize::InstanceMethods</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/44">

<div class="notes">
<p>This is how part of Sequel&#x2019;s after_initialize plugin is implemented.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 10px;"><code>module AfterInitialize
  module ClassMethods
    def call(_)
      v = super
      v.after_initialize
      v
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/45">

<div class="notes">
<p>The class methods module defines the call method.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 10px;"><code>module AfterInitialize
  module <b>ClassMethods</b>
    def call(_)
      v = super
      v.after_initialize
      v
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/46">

<div class="notes">
<p>The call method first calls super to get the default behavior, which returns the model instance with the hash of values.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 10px;"><code>module AfterInitialize
  module ClassMethods
    def call(_)
      <b>v = super</b>
      v.after_initialize
      v
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/47">

<div class="notes">
<p>Then it calls the after_initialize method to run the initialize hooks on that instance.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 10px;"><code>module AfterInitialize
  module ClassMethods
    def call(_)
      v = super
      <b>v.after_initialize</b>
      v
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/48">

<div class="notes">
<p>Then it returns the instance.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 10px;"><code>module AfterInitialize
  module ClassMethods
    def call(_)
      v = super
      v.after_initialize
      <b>v</b>
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/49">

<div class="notes">
<p>By using a plugin to implement initialize hooks, Sequel makes it so only the users that actually need the initialize hooks pay the cost for them. The majority of users do not need initialize hooks and do not have to pay the performance cost for them.|Even for applications that use initialize hooks, they are often only used in a small number of models. With Sequel, you can load the plugin into only the models that need the initialize hooks, so it would not slow down initialization for other models.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
class MyModel &lt; Sequel::Model
  plugin :after_initialize
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/50">

<div class="notes">
<p>By calling super to get the default behavior, it is easy to implement new features using plugins, as well as to extract rarely used features to plugins.|In both Sequel and Roda, most new features are implemented in plugins. Using plugins for most features does not just improve performance, it also saves memory by not allocating as many objects.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 160px; left: 300px;">Plugins</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 200px;">For Most Features</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/51">

<div class="notes">
<p>And that is another general optimization strategy in Ruby. Most objects you create in Ruby take time to allocate, time to mark during garbage collection, and time to free, even if they are not used. This includes all code that is required, even if the code is never used.|Both Sequel and Roda attempt to reduce object allocations. String allocations are probably the easiest to reduce,</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top:150px; left: 180px;">Reduce</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 200px;">Object</h1><h1 class="blue" style="font-size: 120px; position: absolute; top: 385px; left: 200px;">Allocations</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/52">

<div class="notes">
<p>you just need to use frozen string literals. Both Sequel and Roda have used frozen string literals since shortly after they were introduced in Ruby 2.3. Now, frozen string literals did not improve performance much when I added them to Sequel.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code># frozen-string-literal: true
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/53">

<div class="notes">
<p>That was because for years before frozen string literals were introduced, I had stored all strings used to generate SQL in frozen constants, because that used to be the faster than using literal strings.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
SELECT = 'SELECT'.freeze
SPACE = ' '.freeze
FROM = 'FROM'.freeze

def select_sql
  sql = String.new
  sql <span class="ltlt">&#x200C;</span> SELECT <span class="ltlt">&#x200C;</span> SPACE
  sql <span class="ltlt">&#x200C;</span> literal(columns)
  sql <span class="ltlt">&#x200C;</span> SPACE <span class="ltlt">&#x200C;</span> FROM <span class="ltlt">&#x200C;</span> SPACE
  sql <span class="ltlt">&#x200C;</span> literal(table)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/54">

<div class="notes">
<p>After Ruby 2.3 was in wide use, I removed the constants and inlined the strings, which improved SQL building by a few percent. This change made the code significantly easier to read. It also made it easier to see which strings could combined.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code># frozen-string-literal: true




def select_sql
  sql = String.new
  sql <span class="ltlt">&#x200C;</span> <b>"SELECT"</b> <span class="ltlt">&#x200C;</span> <b>" "</b>
  sql <span class="ltlt">&#x200C;</span> literal(columns)
  sql <span class="ltlt">&#x200C;</span> <b>" "</b> <span class="ltlt">&#x200C;</span> <b>"FROM"</b> <span class="ltlt">&#x200C;</span> <b>" "</b>
  sql <span class="ltlt">&#x200C;</span> literal(table)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/55">

<div class="notes">
<p>Combining these strings reduced the number of string operations, further increasing SQL building performance.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code># frozen-string-literal: true




def select_sql
  sql = String.new
  sql <span class="ltlt">&#x200C;</span> <b>"SELECT "</b>
  sql <span class="ltlt">&#x200C;</span> literal(columns)
  sql <span class="ltlt">&#x200C;</span> <b>" FROM "</b>
  sql <span class="ltlt">&#x200C;</span> literal(table)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/56">

<div class="notes">
<p>Sequel tries to improve performance by reducing hash allocations. Sequel used to have code like this in many methods, where the default argument value is a hash.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>class Sequel::Dataset


  def union(dataset, opts={})
    compound_clone(:union, dataset, opts)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/57">

<div class="notes">
<p>The problem with this style is that every call to this method with only a single argument allocates a hash. While allocating a single hash does not sound bad, when many methods do this, you can end up with a lot of unnecessary hashes being allocated.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>class Sequel::Dataset


  def union(dataset, <b>opts={}</b>)
    compound_clone(:union, dataset, opts)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/58">

<div class="notes">
<p>So Sequel started using a empty frozen hash constant, named OPTS.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>class Sequel::Dataset
  <b>OPTS = {}.freeze</b>

  def union(dataset, opts={})
    compound_clone(:union, dataset, opts)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/59">

<div class="notes">
<p>OPTS is used as the default value for most arguments that expect a hash. Using the frozen OPTS hash is almost twice as fast as allocating a new hash.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>class Sequel::Dataset
  OPTS = {}.freeze

  def union(dataset, <b>opts=OPTS</b>)
    compound_clone(:union, dataset, opts)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/60">

<div class="notes">
<p>To save allocations, Sequel often passes the opts hash from one method directly to another method.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>class Sequel::Dataset
  OPTS = {}.freeze

  def union(dataset, opts=OPTS)
    compound_clone(:union, dataset, <b>opts</b>)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/61">

<div class="notes">
<p>Now, why do Sequel and Roda both use option hashes instead of keyword arguments? There are a few reasons for that, but one reason is performance.</p>
</div>
<h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 300px;">Keyword</h1><h1 class="blue" style="font-size: 120px; position: absolute; top: 375px; left: 320px;">Arguments<span class="red">?</span>
</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/62">

<div class="notes">
<p>From a performance standpoint, keyword arguments perform better than option hashes in simple cases.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Faster            # Slower
def a(b: nil)       def a(opts=OPTS)
  b                   opts[:b]
end                 end
a(b: 1)             a(b: 1)
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/63">

<div class="notes">
<p>When you are specifying the keyword argument in the method and calling the method with a keyword argument, using a keyword argument is faster.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Faster            # Slower
def a(<b>b: nil</b>)       def a(opts=OPTS)
  b                   opts[:b]
end                 end
a(<b>b: 1</b>)             a(b: 1)
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/64">

<div class="notes">
<p>However, keyword arguments perform substantially worse if you are using keyword splats, either when using a keyword splat as a method argument,</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Slower            # Faster
def a(<b>**opts</b>)       def a(opts=OPTS)
  opts[:b]            opts[:b]
end                 end
a(b: 1)             a(b: 1)
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/65">

<div class="notes">
<p>when using a keyword splat when calling a method,</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Slower!           # Faster
def a(b: nil)       def a(opts=OPTS)
  b                   opts[:b]
end                 end
a(<b>**hash</b>)           a(hash)
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/66">

<div class="notes">
<p>or especially when using a keyword splat both when calling the method and a keyword splat as a method argument.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Slower!!          # Faster
def a(<b>**opts</b>)       def a(opts=OPTS)
  opts[:b]            opts[:b]
end                 end
a(<b>**hash</b>)           a(hash)
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/67">

<div class="notes">
<p>If you want to write a method named foo that delegates keyword arguments to a method named bar, the obvious, simple, and maintainable approach of using keyword splats is many times slower than the optimal approach.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Slow!
def foo(<b>**opts</b>)
  bar(<b>**opts</b>)
end
def bar(c: nil, d: nil, e: nil)
  c; d; e
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/68">

<div class="notes">
<p>For good performance, you have to take every keyword argument supported by method bar and make it a keyword argument of method foo.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code># Fast
def foo(<b>c: nil, d: nil, e: nil</b>)
  bar(c: c, d: d, e: e)
end
def bar(c: nil, d: nil, e: nil)
  c; d; e
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/69">

<div class="notes">
<p>You also need to explicitly pass each keyword argument when calling bar from foo. This approach makes maintenance more cumbersome.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: nil)
  bar(<b>c: c, d: d, e: e</b>)
end
def bar(c: nil, d: nil, e: nil)
  c; d; e
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/70">

<div class="notes">
<p>Every time you add a keyword argument to bar,</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: nil)
  bar(c: c, d: d, e: e)
end
def bar(c: nil, d: nil, e: nil, <b>f: nil</b>)
  c; d; e; f
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/71">

<div class="notes">
<p>You need to add the keyword argument to foo. Oops, looks like that is not correct.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: nil, <b>f: nil</b>)
  bar(c: c, d: d, e: e)
end
def bar(c: nil, d: nil, e: nil, f: nil)
  c; d; e; f
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/72">

<div class="notes">
<p>You need to make sure to also add it when calling bar from foo.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: nil, f: nil)
  bar(c: c, d: d, e: e, <b>f: f</b>)
end
def bar(c: nil, d: nil, e: nil, f: nil)
  c; d; e; f
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/73">

<div class="notes">
<p>If you change the default value for a keyword argument in bar,</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: nil, f: nil)
  bar(c: c, d: d, e: e, f: f)
end
def bar(c: nil, d: nil, <b>e: 2</b>, f: nil)
  c; d; e; f
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/74">

<div class="notes">
<p>you need to make the same change in foo.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, <b>e: 2</b>, f: nil)
  bar(c: c, d: d, e: e, f: f)
end
def bar(c: nil, d: nil, e: 2, f: nil)
  c; d; e; f
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/75">

<div class="notes">
<p>In general, this approach makes maintenance more difficult and it increases complexity. When you have many methods that delegate option hashes, switching to this approach for keyword arguments is undesireable. I like optimizing code, but not enough to switch to this approach.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: 2, f: nil)
  bar(c: c, d: d, e: e, f: f)
end
def bar(c: nil, d: nil, e: 2, f: nil)
  c; d; e; f
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/76">

<div class="notes">
<p>Especially since this approach is still slower then using an option hash if you have to splat an existing hash when calling foo.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 110px;"><code>
def foo(c: nil, d: nil, e: 2, f: nil)
  bar(c: c, d: d, e: e, f: f)
end
def bar(c: nil, d: nil, e: 2, f: nil)
  c; d; e; f
end
<b>foo(**hash)</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/77">

<div class="notes">
<p>The reason keyword splats are slow is that they allocate hashes.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 30px;"><code>
def kws(**kw) end
def kw(a: nil) end
h = {a: nil}
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/78">

<div class="notes">
<p>Passing no arguments to a method that accepts an optional keyword argument does not allocate a hash.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 30px;"><code>
def kws(**kw) end
def kw(a: nil) end
h = {a: nil}

<b>kw       # 0 hashes</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/79">

<div class="notes">
<p>Passing no arguments to a method that uses a keyword argument splat allocates one hash.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 30px;"><code>
def kws(**kw) end
def kw(a: nil) end
h = {a: nil}

kw       # 0 hashes
<b>kws      # 1 hash</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/80">

<div class="notes">
<p>Passing a keyword splat to a method that accepts an optional keyword argument allocates one to three hashes depending on Ruby version.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 30px;"><code>
def kws(**kw) end
def kw(a: nil) end
h = {a: nil}

kw       # 0 hashes
kws      # 1 hash
<b>kw(**h)  # 1-3 hashes</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/81">

<div class="notes">
<p>Passing a keyword splat to a method that uses a keyword argument splat allocates two to four hashes depending on Ruby version.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 30px;"><code>
def kws(**kw) end
def kw(a: nil) end
h = {a: nil}

kw       # 0 hashes
kws      # 1 hash
kw(**h)  # 1-3 hashes
<b>kws(**h) # 2-4 hashes</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/82">

<div class="notes">
<p>After that extended detour into keyword arguments, let me discuss reducing proc allocations. In general in performance sensitive code, you should avoid allocating procs that are not needed as closures.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top:150px; left: 180px;">Reduce</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 200px;">Proc</h1><h1 class="blue" style="font-size: 120px; position: absolute; top: 385px; left: 220px;">Allocations</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/83">

<div class="notes">
<p>Here is a simplified example from Roda&#x2019;s indifferent params plugin. One thing to notice about this proc is that it does not have any dependencies on the surrounding scope. The proc does not access any instance variables.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
def indifferent_params
  Hash.new { |h, k| h[k.to_s] if k.is_a?(Symbol) }
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/84">

<div class="notes">
<p>The only local variables accessed are the arguments that are yielded to the proc.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
def indifferent_params
  Hash.new { |<b>h</b>, <b>k</b>| <b>h</b>[<b>k</b>.to_s] if <b>k</b>.is_a?(Symbol) }
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/85">

<div class="notes">
<p>The only methods called inside the proc are called on those local variables.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
def indifferent_params
  Hash.new { |h, k| h<b>[</b>k.<b>to_s</b><b>]</b> if k.<b>is_a?</b>(Symbol) }
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/86">

<div class="notes">
<p>This proc can be extracted to a constant,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code><b>IND = proc { |h, k| h[k.to_s] if k.is_a?(Symbol) }</b>
def indifferent_params
  Hash.new(&amp;IND)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/87">

<div class="notes">
<p>and then passed as a block argument to Hash.new. Moving the block to a constant makes this code over 3 times faster.|Extracting objects to constants if the values do not depend on runtime state does not apply just to procs. It applies to most object types. But it is especially beneficial for procs as procs are heavy to allocate.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>IND = proc { |h, k| h[k.to_s] if k.is_a?(Symbol) }
def indifferent_params
  Hash.new(<b>&amp;IND</b>)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/88">

<div class="notes">
<p>If you are not using the proc as a block, and just calling it using the call method, you may be able to avoid allocating procs completely. |For example, Sequel datasets support a row proc, which is a callable object called with each hash retreived from the database. Originally, Sequel::Model used this approach for setting the dataset row proc, where self was the model class.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
@dataset.row_proc = proc { |r| self.load(r) }
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/89">

<div class="notes">
<p>With this approach, every time the row proc was called, it took the row and passed it to the model class&#x2019;s load method, causing an additional indirection for every row returned by Sequel.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
@dataset.row_proc = <b>proc { |r| self.load(r) }</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/90">

<div class="notes">
<p>I guessed that I could improve performance by aliasing the load method to call.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
@dataset.row_proc = proc { |r| self.load(r) }

<b class="block">class <span class="ltlt">&#x200C;</span> Sequel::Model
  alias call load
end</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/91">

<div class="notes">
<p>then assigning the model class itself as the dataset&#x2019;s row_proc. This did turn out to be measurably faster, and is the reason that call is the method used to create new model objects retrieved from the database.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 130px;"><code>
@dataset.row_proc = <b>self</b>

class <span class="ltlt">&#x200C;</span> Sequel::Model
  alias call load
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/92">

<div class="notes">
<p>This brings me to another general optimization principle. To the extent that you can, in performance sensitive code, minimize the amount of indirection, as indirection generally results in slower code.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 120px; left: 220px;">Minimize</h1><h1 class="red" style="font-size: 180px; position: absolute; top: 250px; left: 100px;">Indirection</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/93">

<div class="notes">
<p>Sequel has numerous places where it uses objects that respond to call and wants to use the fastest implementation possible, which is generally the approach with the least indirection. Many of these cases are used to convert strings retrieved from the database to the appropriate ruby types.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top:150px; left: 180px;">Fast</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 200px;">Callables</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/94">

<div class="notes">
<p>If you need a callable for converting a string to an integer, it may be fairly natural to use a lambda. Sequel previously used something like this for type conversion.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| Integer(str) }
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/95">

<div class="notes">
<p>If you look at this method, you see that it is calling the Integer method inside the lambda, which is another indirection.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| <b>Integer(str)</b> }
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/96">

<div class="notes">
<p>So it may make sense to create a Method object for the Integer method. Method objects respond to call just as lambdas do. And it turns out that using a Method object is about 10% faster. But you can still do better than that.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| Integer(str) }
integer = <b>Kernel.method(:Integer)</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/97">

<div class="notes">
<p>It&#x2019;s actually faster to create a plain object,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| Integer(str) }
integer = Kernel.method(:Integer)
integer = <b>Object.new</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/98">

<div class="notes">
<p>and then define a singleton call method on the object. This is faster than using the Method object by almost 10%.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| Integer(str) }
integer = Kernel.method(:Integer)
integer = Object.new
<b>def integer.call(str) Integer(str) end</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/99">

<div class="notes">
<p>However, notice that you still have indirection where you are calling the Integer method from inside the call method. It would probably go faster if you could remove the indirection.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| Integer(str) }
integer = Kernel.method(:Integer)
integer = Object.new
def integer.call(str) <b>Integer(str)</b> end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/100">

<div class="notes">
<p>It turns out that you can avoid the indirection in this case, by aliasing the Integer method to call and making the call method public. This is over 10% faster than the indirect call, and about 37% faster than the original approach of calling the Integer method inside a lambda.|I made this change in Sequel fairly recently, and using this approach for faster callables sped up some benchmarks of Sequel&#x2019;s SQLite adapter by over 10%.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
integer = lambda { |str| Integer(str) }
integer = Kernel.method(:Integer)
integer = Object.new
def integer.call(str) Integer(str) end
<b class="block">class <span class="ltlt">&#x200C;</span> integer
  alias call Integer
  public :call
end
</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/101">

<div class="notes">
<p>In the last example, we saw that calling a method defined with def is faster than calling a lambda. Similarly, how you define a method in Ruby can affect the performance of the method.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 150px; left: 380px;">Defining</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 480px;">Methods</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/102">

<div class="notes">
<p>Let&#x2019;s say you have a method foo that returns 1. In most cases, you would use def to define this method, as in this example.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
def foo
  1
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/103">

<div class="notes">
<p>Now, you could define the method by passing a block to define_method. One of the reasons this is not typically done,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
def foo
  1
end

<b class="block">define_method(:foo) do
  1
end</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/104">

<div class="notes">
<p>is that calling the method defined with define_method is about 50% slower than calling the method defined with def. So in general, you want to prefer defining methods with def.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 60px;"><code>
def foo
  1
end

<b class="block">define_method(:foo) do
  1
end</b>
</code></pre><h1 class="blue" style="font-size: 120px; position: absolute; top: 270px; left: 600px;">50%</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 380px; left: 600px;">Slower</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/105">

<div class="notes">
<p>However, when you need to define methods at runtime, it can be challenging to use def. For one, in order to use def to define methods at runtime, you also need to use eval, which can have security implications.</p>
</div>
<h1 class="blue mono" style="font-size: 150px; position: absolute; top:350px; left: 80px;">def</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 480px; left: 100px;">Challenges</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/106">

<div class="notes">
<p>One place where Sequel dynamically defines methods is for getter and setter methods for model columns. The approach shown here results in methods that are the fastest to call, using class_eval and def.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|



  class_eval("def #{column}; @values[:#{column}] end")



  class_eval("def #{column}=(v) @values[:#{column}] = v end")


end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/107">

<div class="notes">
<p>For a simple column such as name,</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|
  # <b>column # =&gt; "name"</b>


  class_eval("def #{column}; @values[:#{column}] end")



  class_eval("def #{column}=(v) @values[:#{column}] = v end")


end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/108">

<div class="notes">
<p>this approach works fine.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|
  # column # =&gt; "name"


  class_eval("def #{column}; @values[:#{column}] end")
  # <b>def name; @values[:name] end</b>


  class_eval("def #{column}=(v) @values[:#{column}] = v end")
  # <b>def name=(v) @values[:name] = v end</b>

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/109">

<div class="notes">
<p>However, what if the column name has a space in it? If the column is named employee name with a space,</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|
  # column # =&gt; "name"
  # <b>column # =&gt; "employee name"</b>

  class_eval("def #{column}; @values[:#{column}] end")
  # def name; @values[:name] end


  class_eval("def #{column}=(v) @values[:#{column}] = v end")
  # def name=(v) @values[:name] = v end

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/110">

<div class="notes">
<p>you end up with this code.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|
  # column # =&gt; "name"
  # column # =&gt; "employee name"

  class_eval("def #{column}; @values[:#{column}] end")
  # def name; @values[:name] end
  # <b>def employee name; @values[:employee name] end</b>

  class_eval("def #{column}=(v) @values[:#{column}] = v end")
  # def name=(v) @values[:name] = v end
  # <b>def employee name=(v) @values[:employee name] = v end</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/111">

<div class="notes">
<p>Which does not work as this is a SyntaxError. And it is possible if an attacker has control over the column names, that this can be a remote code execution vulnerability.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|
  # column # =&gt; "name"
  # column # =&gt; "employee name"

  class_eval("def #{column}; @values[:#{column}] end")
  # def name; @values[:name] end
  # def employee name; @values[<b>:employee name</b>] end

  class_eval("def #{column}=(v) @values[:#{column}] = v end")
  # def name=(v) @values[:name] = v end
  # def employee name=(v) @values[:employee name] = v end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/112">

<div class="notes">
<p>If you want to be safe, you need to use define_method to define the column getters and setters. This is unfortunate as the vast majority of cases could be handled correctly and faster using def instead of define_method.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns.each do |column|
  column = column.to_sym
  
<b class="block">  define_method(column) do
    @values[column]
  end

  define_method(:"#{column}=") do |v|
    @values[column] = v
  end</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/113">

<div class="notes">
<p>What Sequel actually does is attempt to get the best of both worlds.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns, bad_columns = columns.partition do |x|
  /\A[A-Za-z][A-Za-z0-9]*\z/.match(x.to_s)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/114">

<div class="notes">
<p>It partitions the column names to separate the good column names from the bad column names.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
<b>columns, bad_columns</b> = columns.<b>partition</b> do |x|
  /\A[A-Za-z][A-Za-z0-9]*\z/.match(x.to_s)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/115">

<div class="notes">
<p>For the good column names that can be valid literal method names, Sequel uses def to define them for maximum performance. For the bad column names that cannot be valid literal method names, Sequel uses define_method so that calling the methods still works if you use send.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
columns, bad_columns = columns.partition do |x|
  <b>/\A[A-Za-z][A-Za-z0-9]*\z/.match(x.to_s)</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/116">

<div class="notes">
<p>This is another general optimization principle that both Sequel and Roda use. Let&#x2019;s say you have a fast approach that works for simple cases, but that fails in more complex cases. Assuming the simple case is more common than the complex case, you can speed up the code by separating the two cases, using the fast approach for the simple cases, and using the slow approach for the complex cases.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top:150px; left: 60px;">Separate</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 140px;">Common</h1><h1 class="blue" style="font-size: 60px; position: absolute; top: 385px; left: 230px;">from</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 400px; left: 140px;">Uncommon</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/117">

<div class="notes">
<p>In general both Sequel and Roda have a preference for def over define_method in performance sensitive code. However, there is one case where define_method is preferred for performance reasons.</p>
</div>
<h1 class="blue mono" style="font-size: 150px; position: absolute; top:150px; left: 80px;">define_method</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 270px; left: 480px;">Advantages</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/118">

<div class="notes">
<p>Assume you have a class method that defines an instance method.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
def def_numbers(first, last)
  class_eval("def numbers; (#{first}..#{last}).to_a.freeze end")
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/119">

<div class="notes">
<p>The class method takes two integer arguments,</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
def def_numbers(<b>first</b>, <b>last</b>)
  class_eval("def numbers; (#{first}..#{last}).to_a.freeze end")
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/120">

<div class="notes">
<p>and defines an instance method named numbers that will return a frozen array created from the range between two arguments. The performance issue with using class_eval and def is that every time the numbers method is called, it needs to recompute the array.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
def def_numbers(first, last)
  class_eval("def numbers; <b>(#{first}..#{last}).to_a.freeze</b> end")
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/121">

<div class="notes">
<p>It is faster to compute this array up front.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
def def_numbers(first, last)
  #class_eval("def numbers; (#{first}..#{last}).to_a.freeze end")
  <b>array = (first..last).to_a.freeze</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/122">

<div class="notes">
<p>Then you can use define_method to define the instance method.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
def def_numbers(first, last)
  #class_eval("def numbers; (#{first}..#{last}).to_a.freeze end")
  array = (first..last).to_a.freeze
<b class="block">  define_method(:numbers) do
    array
  end</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/123">

<div class="notes">
<p>When the instance method is defined this way, it can return the array that was created when the class method was called, which is much faster than recomputing the array.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 60px;"><code>
def def_numbers(first, last)
  #class_eval("def numbers; (#{first}..#{last}).to_a.freeze end")
  array = (first..last).to_a.freeze
  define_method(:numbers) do
    <b>array</b>
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/124">

<div class="notes">
<p>The basic principle here for performance is to prefer def over define_method for definining methods as they are faster to call,</p>
</div>
<h1 class="blue mono" style="font-size: 100px; position: absolute; top:350px; left: 40px;">def <span class="red">&gt;</span> define_method</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/125">

<div class="notes">
<p>unless you can access local variables in the surrounding scope to avoid computation inside the method.</p>
</div>
<h1 class="blue mono" style="font-size: 100px; position: absolute; top:350px; left: 40px;">def <span class="red">&lt;</span> define_method</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/126">

<div class="notes">
<p>Related to this, if you are accepting blocks and storing them, and later using instance exec to execute them on instances of a class, it is faster to create an instance method using define_method, and then call that method on the instances of the class.</p>
</div>
<h1 class="blue mono" style="font-size: 64px; position: absolute; top:350px; left: 40px;">instance_exec <span class="red">&lt;</span> define_method</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/127">

<div class="notes">
<p>Let&#x2019;s implement a before hook to demonstrate this idea. Here you have a before class method that takes a block, and a before instance method that will execute all the blocks passed to the class method in the context of the instance.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)








end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/128">

<div class="notes">
<p>One simple approach to this is to store each block in an instance variable in the class.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  <b>before_hooks <span class="ltlt">&#x200C;</span> block</b>







end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/129">

<div class="notes">
<p>Then in the before instance method, iterate over the array of blocks and instance exec each one. While this is a simple approach, it is also slow, partly because instance_exec creates a singleton class for the instance. It is faster to use methods.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> block







end

def before
  <b>self.class.before_hooks.each { |b| instance_exec(&amp;b) }</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/130">

<div class="notes">
<p>You start by selecting a method name for each block, based on the position in the before hooks array.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  <b>meth = :"_before_hook_#{before_hooks.length}"</b>







end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/131">

<div class="notes">
<p>You then pass the block to define_method to create an instance method.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  <b>define_method(meth, &amp;block)</b>






end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/132">

<div class="notes">
<p>Then you add that method name to the array of before hooks</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  <b>before_hooks <span class="ltlt">&#x200C;</span> meth</b>





end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/133">

<div class="notes">
<p>In the instance method, you iterate over the array of method names, then use send to call each method. This is faster, but you can still do better.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth





end

def before
  <b>self.class.before_hooks.each { |m| send(m) }</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/134">

<div class="notes">
<p>Since you know which methods will be executed, you can define the before instance method using class eval and def. This is faster as it avoids the need to call each on the array. Each method call is faster since you are calling it directly instead of indirectly via send.|This approach is pretty close to optimal. But if there is a only a single before hook, which is a relatively common case, you can do a little bit better.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  <b>class_eval("def before; #{before_hooks.join(';')} end")</b>




end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/135">

<div class="notes">
<p>You check if there is more than one before hook method defined.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if <b>before_hooks.length &gt; 1</b>
    class_eval("def before; #{before_hooks.join(';')} end")
  else

  end
end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/136">

<div class="notes">
<p>If so, you define the method as you did before.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    <b>class_eval("def before; #{before_hooks.join(';')} end")</b>
  else

  end
end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/137">

<div class="notes">
<p>But if there is only a single before hook method defined, you alias before to the before hook method, which saves a method call at runtime.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    <b>class_eval("alias before #{before_hooks.first}")</b>
  end
end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/138">

<div class="notes">
<p>You still want to keep the empty before instance method defined, so if that no before hooks are added, everything still works.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    class_eval("alias before #{before_hooks.first}")
  end
end

<b class="block">def before

end</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/139">

<div class="notes">
<p>This approach for defining methods for hooks instead of using instance_exec is over twice as fast, mostly because it avoids a lot of internal indirection. Unfortunately, switching from instance_exec to define_method presents backwards compatibility issues.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    class_eval("alias before #{before_hooks.first}")
  end
end

def before

end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/140">

<div class="notes">
<p>If you pass a block that accepts an argument to the before method, this will work fine if you use instance_exec, but will cause an ArgumentError at runtime if you switch to define_method. Thankfully, you can work around this problem.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    class_eval("alias before #{before_hooks.first}")
  end
end

<b>before { |x| }</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/141">

<div class="notes">
<p>You check the arity of the block. If the block requires an argument,</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  unless <b>block.arity == 0 || block.arity == -1</b>


  end
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    class_eval("alias before #{before_hooks.first}")
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/142">

<div class="notes">
<p>you assign the block to a different variable,</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  unless block.arity == 0 || block.arity == -1
    <b>b = block</b>

  end
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    class_eval("alias before #{before_hooks.first}")
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/143">

<div class="notes">
<p>Then you define a new block that accepts no arguments, and calls instance_exec with the previous block. I used this approach recently in Roda, when I switched from using instance_exec to using define_method for handling many blocks. This allowed me to keep backwards compatibility, but speed up the common case of route dispatching by over 60%.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.before(&amp;block)
  meth = :"_before_hook_#{before_hooks.length}"
  unless block.arity == 0 || block.arity == -1
    b = block
    <b>block = lambda { instance_exec(&amp;b) }</b>
  end
  define_method(meth, &amp;block)
  before_hooks <span class="ltlt">&#x200C;</span> meth
  if before_hooks.length &gt; 1
    class_eval("def before; #{before_hooks.join(';')} end")
  else
    class_eval("alias before #{before_hooks.first}")
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/144">

<div class="notes">
<p>One of the best places to start optimizing is inside any inner loops. Even small improvements inside inner loops can result in significant improvements if there are a lot of iterations.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:150px; left: 60px;">Optimize</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 260px; left: 130px;">Inner</h1><h1 class="red" style="font-size: 200px; position: absolute; top:330px; left: 60px;">Loops</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/145">

<div class="notes">
<p>I am going to use an actual optimization taken from Sequel&#x2019;s SQLAnywhere adapter as an example. The SQLAnywhere adapter was submitted via a pull request,</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:65px; left: 200px;">Sequel</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 180px; left: 140px;">SQLAnywhere</h1><h1 class="red" style="font-size: 200px; position: absolute; top:300px; left: 150px;">Adapter</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/146">

<div class="notes">
<p>and this was the function for returning rows.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>
def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  execute(sql) do |rs|
    max_cols = db.api.sqlany_num_cols(rs)
    col_map = {}
    max_cols.times do |cols|
      col_map[db.api.sqlany_get_column_info(rs, cols)[2]] =
          output_identifier(db.api.sqlany_get_column_info(rs, cols)[2])
    end

    @columns  = col_map.values
    convert = (convert_smallint_to_bool and db.convert_smallint_to_bool)

    while db.api.sqlany_fetch_next(rs) == 1
      max_cols = db.api.sqlany_num_cols(rs)
      h2 = {}
      max_cols.times do |cols|
        h2[col_map[db.api.sqlany_get_column_info(rs, cols)[2]]||db.api.sqlany_get_column_info(rs, cols)[2]] =
          cps[db.api.sqlany_get_column_info(rs, cols)[4]].nil? ?
              db.api.sqlany_get_column(rs, cols)[1] :
                db.api.sqlany_get_column_info(rs, cols)[4] != 500 ?
                  cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(db.api.sqlany_get_column(rs, cols)[1]) :
                    convert ? cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(db.api.sqlany_get_column(rs, cols)[1]) :
                      db.api.sqlany_get_column(rs, cols)[1]
      end
      yield h2
    end unless rs.nil?
  end
  self
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/147">

<div class="notes">
<p>This is the inner loop, called for every column of every row. Even this is a lot of code, but I will only be focusing on a few parts. One thing that I found almost amusing about this code,</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>
def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  execute(sql) do |rs|
    max_cols = db.api.sqlany_num_cols(rs)
    col_map = {}
    max_cols.times do |cols|
      col_map[db.api.sqlany_get_column_info(rs, cols)[2]] =
          output_identifier(db.api.sqlany_get_column_info(rs, cols)[2])
    end

    @columns  = col_map.values
    convert = (convert_smallint_to_bool and db.convert_smallint_to_bool)

    while db.api.sqlany_fetch_next(rs) == 1
      max_cols = db.api.sqlany_num_cols(rs)
      h2 = {}
      max_cols.times do |cols|
<b class="block">         h2[col_map[db.api.sqlany_get_column_info(rs, cols)[2]]||db.api.sqlany_get_column_info(rs, cols)[2]] =
          cps[db.api.sqlany_get_column_info(rs, cols)[4]].nil? ?
              db.api.sqlany_get_column(rs, cols)[1] :
                db.api.sqlany_get_column_info(rs, cols)[4] != 500 ?
                  cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(db.api.sqlany_get_column(rs, cols)[1]) :
                    convert ? cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(db.api.sqlany_get_column(rs, cols)[1]) :
                      db.api.sqlany_get_column(rs, cols)[1]</b>
      end
      yield h2
    end unless rs.nil?
  end
  self
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/148">

<div class="notes">
<p>was this nesting of ternery operators 3 levels deep, with no parentheses. Now, that is not my prefered coding style. That was not the reason for the performance issue in this code, though. The reason this code was slow,</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>
def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  execute(sql) do |rs|
    max_cols = db.api.sqlany_num_cols(rs)
    col_map = {}
    max_cols.times do |cols|
      col_map[db.api.sqlany_get_column_info(rs, cols)[2]] =
          output_identifier(db.api.sqlany_get_column_info(rs, cols)[2])
    end

    @columns  = col_map.values
    convert = (convert_smallint_to_bool and db.convert_smallint_to_bool)

    while db.api.sqlany_fetch_next(rs) == 1
      max_cols = db.api.sqlany_num_cols(rs)
      h2 = {}
      max_cols.times do |cols|
        h2[col_map[db.api.sqlany_get_column_info(rs, cols)[2]]||db.api.sqlany_get_column_info(rs, cols)[2]] =
          cps[db.api.sqlany_get_column_info(rs, cols)[4]].nil? <b>?</b>
              db.api.sqlany_get_column(rs, cols)[1] <b>:</b>
                db.api.sqlany_get_column_info(rs, cols)[4] != 500 <b>?</b>
                  cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(db.api.sqlany_get_column(rs, cols)[1]) <b>:</b>
                    convert <b>?</b> cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(db.api.sqlany_get_column(rs, cols)[1]) <b>:</b>
                      db.api.sqlany_get_column(rs, cols)[1]
      end
      yield h2
    end unless rs.nil?
  end
  self
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/149">

<div class="notes">
<p>was these calls to db.api.sqlany_get_column_info with the same 2 arguments. This method is called up to 5 times in the inner loop. This method returns an array, and only 2 elements of this array are needed, the name of the column and the type of the column. Note that the names of the columns and types of the columns are the same for each row in the result set, as such this method does not need to be called in the inner loop at all.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>
def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  execute(sql) do |rs|
    max_cols = db.api.sqlany_num_cols(rs)
    col_map = {}
    max_cols.times do |cols|
      col_map[db.api.sqlany_get_column_info(rs, cols)[2]] =
          output_identifier(db.api.sqlany_get_column_info(rs, cols)[2])
    end

    @columns  = col_map.values
    convert = (convert_smallint_to_bool and db.convert_smallint_to_bool)

    while db.api.sqlany_fetch_next(rs) == 1
      max_cols = db.api.sqlany_num_cols(rs)
      h2 = {}
      max_cols.times do |cols|
        h2[col_map[<b>db.api.sqlany_get_column_info(rs, cols)</b>[2]]||<b>db.api.sqlany_get_column_info(rs, cols)</b>[2]] =
          cps[<b>db.api.sqlany_get_column_info(rs, cols)</b>[4]].nil? ?
              db.api.sqlany_get_column(rs, cols)[1] :
                <b>db.api.sqlany_get_column_info(rs, cols)</b>[4] != 500 ?
                  cps[<b>db.api.sqlany_get_column_info(rs, cols)</b>[4]].call(db.api.sqlany_get_column(rs, cols)[1]) :
                    convert ? cps[<b>db.api.sqlany_get_column_info(rs, cols)</b>[4]].call(db.api.sqlany_get_column(rs, cols)[1]) :
                      db.api.sqlany_get_column(rs, cols)[1]
      end
      yield h2
    end unless rs.nil?
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 480px; font-size: 32px; margin-top: 10px; border: 3px dotted #00005B; padding: 10px;"><code>db.api.sqlany_get_column_info(rs, cols)</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/150">

<div class="notes">
<p>These calls are to db.api.sqlany_get_column with the same 2 arguments. This method also returns an array, and only the second element of the array is needed, which is the value of the column in the current row. This method, while it appears 4 times in the inner loop, is only ever called once, depending on which branch each ternery operator takes. This method does depend on the current position in the result set, and as such it does need to be called in the inner loop.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>
def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  execute(sql) do |rs|
    max_cols = db.api.sqlany_num_cols(rs)
    col_map = {}
    max_cols.times do |cols|
      col_map[db.api.sqlany_get_column_info(rs, cols)[2]] =
          output_identifier(db.api.sqlany_get_column_info(rs, cols)[2])
    end

    @columns  = col_map.values
    convert = (convert_smallint_to_bool and db.convert_smallint_to_bool)

    while db.api.sqlany_fetch_next(rs) == 1
      max_cols = db.api.sqlany_num_cols(rs)
      h2 = {}
      max_cols.times do |cols|
        h2[col_map[db.api.sqlany_get_column_info(rs, cols)[2]]||db.api.sqlany_get_column_info(rs, cols)[2]] =
          cps[db.api.sqlany_get_column_info(rs, cols)[4]].nil? ?
              <b>db.api.sqlany_get_column(rs, cols)[1]</b> :
                db.api.sqlany_get_column_info(rs, cols)[4] != 500 ?
                  cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(<b>db.api.sqlany_get_column(rs, cols)[1]</b>) :
                    convert ? cps[db.api.sqlany_get_column_info(rs, cols)[4]].call(<b>db.api.sqlany_get_column(rs, cols)[1]</b>) :
                      <b>db.api.sqlany_get_column(rs, cols)[1]</b>
      end
      yield h2
    end unless rs.nil?
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 480px; font-size: 32px; margin-top: 10px; border: 3px dotted #00005B; padding: 10px;"><code>db.api.sqlany_get_column(rs, cols)[1]</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/151">

<div class="notes">
<p>Here is the final code after optimization.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end
        yield h
      end
    end
  end
  self
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/152">

<div class="notes">
<p>This highlighted section is the inner loop. One thing to note about this inner loop is that all operations inside it are on local variables.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
<b class="block">        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end</b>
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 300px; border: 3px dotted #00005B; padding: 10px;"><code>while (i+=1) <span class="lt"> max</span>
  name, cp = col_infos[i]
  v = api.sqlany_get_column(rs, i)[1]
  h[name] = cp &amp;&amp; v ? cp.call(v) : v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/153">

<div class="notes">
<p>To make that possible, we need to set the local variables the inner loop uses before the start of the inner loop. This way we do not have to call methods or reference instance variables to get this data inside the inner loop. It may seem like this is not that important, but if you are retrieving 10,000 rows and each row has 100 columns, defining these 2 local variables outside the inner loop and using them inside the inner loop saves 2 million method calls.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  <b>api = db.api</b>
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    <b>max = col_infos.length</b>

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 580px; font-size: 32px; margin-top: 150px; border: 3px dotted #00005B; padding: 10px;"><code>api = db.api
max = col_infos.length
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/154">

<div class="notes">
<p>This is another general Ruby optimization principle, which is to prefer using local variables whenever possible, and especially in inner loops.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:150px; left: 60px;">Prefer</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 260px; left: 150px;">Local</h1><h1 class="red" style="font-size: 200px; position: absolute; top:380px; left: 60px;">Variables</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none">
  <div class="content " ref="slides/slides/155">

<div class="notes">
<p>Local variable access is faster than instance variable access.</p>
</div>
<h1 class="red" style="font-size: 350px; position: absolute; top: 150px; left: 500px;">&gt;</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 250px; left: 70px;">Local<br>Variables</br><h1 class="blue" style="font-size: 100px; position: absolute; top: 250px; left: 770px;">Instance<br>Variables</br></h1>
</h1>
</div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/156">

<div class="notes">
<p>Local variable access is faster than constant access.</p>
</div>
<h1 class="red" style="font-size: 350px; position: absolute; top: 150px; left: 500px;">&gt;</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 250px; left: 70px;">Local<br>Variables</br><h1 class="blue" style="font-size: 100px; position: absolute; top: 300px; left: 770px;">Constants</h1></h1>
</div>
</div><div id="slides/slides" class="slide " data-transition="none">
  <div class="content " ref="slides/slides/157">

<div class="notes">
<p>Local variable access is faster than method calls.</p>
</div>
<h1 class="red" style="font-size: 350px; position: absolute; top: 150px; left: 500px;">&gt;</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 250px; left: 70px;">Local<br>Variables</br><h1 class="blue" style="font-size: 100px; position: absolute; top: 250px; left: 770px;">Method<br>Calls</br></h1>
</h1>
</div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/158">

<div class="notes">
<p>Local variables are faster than instance variables, constants, and method calls because they minimize the amount of internal indirection.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 120px; left: 220px;">Minimize</h1><h1 class="red" style="font-size: 180px; position: absolute; top: 250px; left: 100px;">Indirection</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/159">

<div class="notes">
<p>Whenever you can store the result of an instance variable, constant, or method call in a local variable before a loop, and access the local variable inside the loop, doing so will improve performance.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:150px; left: 60px;">Prefer</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 260px; left: 150px;">Local</h1><h1 class="red" style="font-size: 200px; position: absolute; top:380px; left: 60px;">Variables</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/160">

<div class="notes">
<p>Getting back to the the inner loop optimization example, that sqlany_get_column_info method that was previously called up to 5 times in the inner loop is now no longer called inside the inner loop, it is only called one time per column before the inner loop to get the name and type of the column.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = <b>api.sqlany_get_column_info(rs, i)</b>
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 480px; font-size: 32px; margin-top: 10px; border: 3px dotted #00005B; padding: 10px;"><code>db.api.sqlany_get_column_info(rs, cols)</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/161">

<div class="notes">
<p>We use the type of the column to get a convertor object to convert the database value to the appropriate ruby type.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
<b class="block">      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end</b>
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 580px; font-size: 32px; margin-top: 150px; border: 3px dotted #00005B; padding: 10px;"><code>cp = if type == 500
  cps[500] if convert
else
  cps[type]
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/162">

<div class="notes">
<p>We store the column name and convertor for each column in an array of column infos.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      <b>col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]</b>
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 380px; font-size: 32px; margin-top: 150px; border: 3px dotted #00005B; padding: 10px;"><code>col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/163">

<div class="notes">
<p>The first line inside the inner loop retrieves the column name and convertor object from that array of column infos.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
<b class="block">        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end</b>
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 300px; border: 3px dotted #00005B; padding: 10px;"><code>while (i+=1) <span class="lt"> max</span>
  <b>name, cp = col_infos[i]</b>
  v = api.sqlany_get_column(rs, i)[1]
  h[name] = cp &amp;&amp; v ? cp.call(v) : v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/164">

<div class="notes">
<p>In the next line, we call the api.sqlany_get_column method to get the value of the column.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
<b class="block">        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end</b>
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 300px; border: 3px dotted #00005B; padding: 10px;"><code>while (i+=1) <span class="lt"> max</span>
  name, cp = col_infos[i]
  <b>v = api.sqlany_get_column(rs, i)[1]</b>
  h[name] = cp &amp;&amp; v ? cp.call(v) : v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/165">

<div class="notes">
<p>In the third line, if there is a convertor and the value of the column is not nil, we call the convertor with the value to get the appropriate ruby object.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
<b class="block">        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end</b>
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 300px; border: 3px dotted #00005B; padding: 10px;"><code>while (i+=1) <span class="lt"> max</span>
  name, cp = col_infos[i]
  v = api.sqlany_get_column(rs, i)[1]
  h[name] = <b>cp &amp;&amp; v ? cp.call(v)</b> : v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/166">

<div class="notes">
<p>We then set that object for the column name in the hash.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
<b class="block">        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end</b>
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 300px; border: 3px dotted #00005B; padding: 10px;"><code>while (i+=1) <span class="lt"> max</span>
  name, cp = col_infos[i]
  v = api.sqlany_get_column(rs, i)[1]
  <b>h[name] = cp &amp;&amp; v ? cp.call(v) : v</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/167">

<div class="notes">
<p>One thing to note here is the deliberate use of while instead of using col_infos.each. Inner loops like this one are one of the few places where it makes sense to use while instead of each, as that change alone can improve real world performance by a couple percent. Using each for inner loops can hurt performance because it requires a separate stack frame to be pushed and popped for each iteration.</p>
</div>
<pre class="sh_ruby" style="font-size: 16px; margin-top: 10px;"><code>def fetch_rows(sql)
  db = @db
  cps = db.conversion_procs
  api = db.api
  execute(sql) do |rs|
    convert = convert_smallint_to_bool
    col_infos = []
    api.sqlany_num_cols(rs).times do |i|
      _, _, name, _, type = api.sqlany_get_column_info(rs, i)
      cp = if type == 500
        cps[500] if convert
      else
        cps[type]
      end
      col_infos <span class="ltlt">&#x200C;</span> [output_identifier(name), cp]
    end

    self.columns = col_infos.map(&amp;:first)
    max = col_infos.length

    if rs
      while api.sqlany_fetch_next(rs) == 1
        i = -1
        h = {}
<b class="block">        while (i+=1) <span class="lt"> max</span>
          name, cp = col_infos[i]
          v = api.sqlany_get_column(rs, i)[1]
          h[name] = cp &amp;&amp; v ? cp.call(v) : v
        end</b>
        yield h
      end
    end
  end
  self
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 500px; font-size: 32px; margin-top: 300px; border: 3px dotted #00005B; padding: 10px;"><code><b>while (i+=1) <span class="lt"> max</span></b>
  name, cp = col_infos[i]
  v = api.sqlany_get_column(rs, i)[1]
  h[name] = cp &amp;&amp; v ? cp.call(v) : v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/168">

<div class="notes">
<p>I am going to change pace from the lower level optimization techniques I have been focusing on so far, and discuss something that actually becomes more important as your application becomes larger. And that is choosing faster algorithms, such as the algorithm used to route web requests.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top:150px; left: 260px;">Choose</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 300px;">Faster</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 385px; left: 340px;">Algorithms</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/169">

<div class="notes">
<p>For hello world benchmarks with a single route, the routing algorithm does not matter, and performance only depends on the overhead of the routing implementation. Roda has very low overhead, so it does well in the single route case.</p>
</div>
<h1 class="red" style="font-size: 120px; position: absolute; top: 160px; left: 60px;">Single</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 245px; left: 140px;">Route</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/170">

<div class="notes">
<p>However, when you have thousands of routes in your web application, the algorithm you use for routing becomes much more important than the amount of overhead in the routing implementation.</p>
</div>
<h1 class="blue" style="font-size: 120px; position: absolute; top: 80px; left: 230px;">Thousands</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 180px; left: 480px;">of</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 245px; left: 340px;">Routes</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/171">

<div class="notes">
<p>For years before working on Roda, I used Sinatra for most web development. One issue with Sinatra is that the time taken to route requests is proportional to the number of routes.</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O(<span class="red">n</span>)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/172">

<div class="notes">
<p>A simplified version of Sinatra&#x2019;s router looks like this.</p>
</div>
<pre class="sh_ruby" style="font-size: 36px; margin-top: 50px;"><code>
def route
  routes = self.class.routes[@request.request_method]
  routes.each do |pattern, unbound_method|
    if match(pattern, @request.path)
      res = unbound_method.bind(self).call
      throw :halt, res
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/173">

<div class="notes">
<p>Sinatra first gets an array of all routes for the request method, such as GET or POST.</p>
</div>
<pre class="sh_ruby" style="font-size: 36px; margin-top: 50px;"><code>
def route
  <b>routes = self.class.routes[@request.request_method]</b>
  routes.each do |pattern, unbound_method|
    if match(pattern, @request.path)
      res = unbound_method.bind(self).call
      throw :halt, res
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/174">

<div class="notes">
<p>Sinatra iterates over each of these routes.</p>
</div>
<pre class="sh_ruby" style="font-size: 36px; margin-top: 50px;"><code>
def route
  routes = self.class.routes[@request.request_method]
  <b>routes.each</b> do |pattern, unbound_method|
    if match(pattern, @request.path)
      res = unbound_method.bind(self).call
      throw :halt, res
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/175">

<div class="notes">
<p>Sinatra checks if the current route matches the request path.</p>
</div>
<pre class="sh_ruby" style="font-size: 36px; margin-top: 50px;"><code>
def route
  routes = self.class.routes[@request.request_method]
  routes.each do |pattern, unbound_method|
    if <b>match(pattern, @request.path)</b>
      res = unbound_method.bind(self).call
      throw :halt, res
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/176">

<div class="notes">
<p>If so, Sinatra takes the unbound method for the route, creates a Method object, and calls the Method object to get the rack response array.</p>
</div>
<pre class="sh_ruby" style="font-size: 36px; margin-top: 50px;"><code>
def route
  routes = self.class.routes[@request.request_method]
  routes.each do |pattern, unbound_method|
    if match(pattern, @request.path)
      <b>res = unbound_method.bind(self).call</b>
      throw :halt, res
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/177">

<div class="notes">
<p>Then, like Roda, Sinatra uses throw to return the rack response array to the webserver.</p>
</div>
<pre class="sh_ruby" style="font-size: 36px; margin-top: 50px;"><code>
def route
  routes = self.class.routes[@request.request_method]
  routes.each do |pattern, unbound_method|
    if match(pattern, @request.path)
      res = unbound_method.bind(self).call
      <b>throw :halt, res</b>
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/178">

<div class="notes">
<p>This works fine if you have a small number of routes. But if you have thousands of routes, Sinatra applications can spend a large proportion of request time iterating over the array of routes looking for a matching route, instead of running the user&#x2019;s code. This is one reason Sinatra is rarely used for applications with a large number of routes.</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O(<span class="red">n</span>)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/179">

<div class="notes">
<p>Roda uses a routing tree, where once you take one branch of the tree, you ignore other branches. This results in roughly O(log(n)) performance for routing in most web applications.</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O( )</h1><h1 class="red mono" style="font-size: 160px; position: absolute; top: 250px; left: 510px;">log(n)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/180">

<div class="notes">
<p>A brief example of this is the following routing tree.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
Roda.route do |r|
  r.on "foo" do
    # /foo branch
  end

  r.on "bar" do
    # /bar branch
  end

  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/181">

<div class="notes">
<p>After Roda yields control to the route block, the r.on method is called with the string foo, which checks to see if the first segment of the request path is foo.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
Roda.route do |r|
  <b>r.on "foo"</b> do
    # /foo branch
  end

  r.on "bar" do
    # /bar branch
  end

  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/182">

<div class="notes">
<p>If so, then the block yields, and only routes inside that block are considered. All routes for other initial segments are no longer considered.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
Roda.route do |r|
  r.on "foo" do
    # <b>/foo branch</b>
  end

  r.on "bar" do
    # /bar branch
  end

  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/183">

<div class="notes">
<p>If the first segment of the path is not foo, the r.on method returns without yielding to the block.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
Roda.route do |r|
  <b>r.on "foo"</b> do
    # /foo branch
  end

  r.on "bar" do
    # /bar branch
  end

  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/184">

<div class="notes">
<p>Then control continues with the next routing method call.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
Roda.route do |r|
  r.on "foo" do
    # /foo branch
  end

  <b>r.on "bar"</b> do
    # /bar branch
  end

  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/185">

<div class="notes">
<p>So in Roda that there is a linear search of the initial segments of the tree. Now, for most routing trees, that is not a major issue.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
Roda.route do |r|
  <b>r.on "foo"</b> do
    # /foo branch
  end

  <b>r.on "bar"</b> do
    # /bar branch
  end

  # ...
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/186">

<div class="notes">
<p>However, if you had a completely flat URL structure where all initial path segments were distinct, then Roda&#x2019;s routing tree would devolve back to linear search behavior, similar to Sinatra.|I did not consider that acceptable, so for that reason and for general code organization, Roda has offered multi_route plugin since the initial release.</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O(<span class="red">n</span>)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/187">

<div class="notes">
<p>Here&#x2019;s a similar routing tree using Roda&#x2019;s multi_route plugin.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :multi_route

Roda.route('foo') do |r|
  # /foo branch
end
Roda.route('bar') do |r|
  # /bar branch
end
# ...

Roda.route do |r|
  r.multi_route
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/188">

<div class="notes">
<p>The main difference here are the routing trees for the foo initial segment and bar initial segment are outside the main routing tree, and would usually be stored in separate files. Roda takes all of these initial segments and builds a regular expression.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :multi_route

Roda.<b>route('foo')</b> do |r|
  # /foo branch
end
Roda.<b>route('bar')</b> do |r|
  # /bar branch
end
# ...

Roda.route do |r|
  r.multi_route
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/189">

<div class="notes">
<p>In the main routing tree, the r.multi_route method is called, which will use that regular expression to match against all initial segments that have been registered, and then dispatch to the appropriate routing block.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :multi_route

Roda.route('foo') do |r|
  # /foo branch
end
Roda.route('bar') do |r|
  # /bar branch
end
# ...

Roda.route do |r|
  <b>r.multi_route</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/190">

<div class="notes">
<p>This allows for roughly O(log(n)) routing performance for the initial route segments. The multi_route plugin also supports namespaces, which allows for O(log(n)) routing performance at all levels of the routing tree.</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O( )</h1><h1 class="red mono" style="font-size: 160px; position: absolute; top: 250px; left: 510px;">log(n)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/191">

<div class="notes">
<p>And that is great, but what if you could make routing performance be O(1), so routing had roughly the same performance regardless of the number of routes?</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O(<span class="red">1</span>)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/192">

<div class="notes">
<p>Roda supports that using the static routing plugin. This plugin allows for O(1) routing for statically defined routes. This is the fastest way to route requests, but unfortunately you lose the main advantage of Roda, which is the ability to operate on a request at any point during routing.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :static_routing

Roda.static_get('/foo') do |r|
  # GET /foo
end
Roda.static_get('/bar') do |r|
  # GET /bar
end
# ...

Roda.route do |r|
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/193">

<div class="notes">
<p>With the static routing plugin, you need to provide the full path of the request to match against when specifying the route for that block. Roda will put all of these static route paths in a hash.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :static_routing

Roda.<b>static_get('/foo')</b> do |r|
  # GET /foo
end
Roda.<b>static_get('/bar')</b> do |r|
  # GET /bar
end
# ...

Roda.route do |r|
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/194">

<div class="notes">
<p>Before the normal routing tree is called, Roda will check if the path of the request is in hash of static route paths. If so, it will dispatch to the appropriate route block.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :static_routing

Roda.static_get('/foo') do |r|
  # GET /foo
end
Roda.static_get('/bar') do |r|
  # GET /bar
end
# ...

<b>Roda.route</b> do |r|
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/195">

<div class="notes">
<p>When using the static_routing plugin, the difference in routing speed between 10 routes and 10,000 routes,</p>
</div>
<h1 class="blue mono" style="font-size: 180px; position: absolute; top: 250px; left: 40px;">10</h1><h1 class="red" style="font-size: 250px; position: absolute; top: 175px; left: 320px;">&#x2192;</h1><h1 class="blue mono" style="font-size: 180px; position: absolute; top: 250px; left: 540px;">10,000</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/196">

<div class="notes">
<p>is around 15%. The TechEmpower benchmarks for Roda use the static_routing plugin to get the maximum performance, even though they only have 6 routes.</p>
</div>
<h1 class="blue mono" style="font-size: 180px; position: absolute; top: 250px; left: 40px;">10</h1><h1 class="red" style="font-size: 250px; position: absolute; top: 175px; left: 320px;">&#x2192;</h1><h1 class="blue mono" style="font-size: 180px; position: absolute; top: 250px; left: 540px;">10,000</h1><h1 class="red" style="font-size: 150px; position: absolute; top: 400px; left: 120px;">15% Difference</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/197">

<div class="notes">
<p>So Roda&#x2019;s static_routing plugin gives you O(1) routing, but you have to give up the main advantage of Roda. Wouldn&#x2019;t it be great to keep O(1) routing, but still be able to operate on the request at any point during routing? I thought it would.</p>
</div>
<h1 class="blue mono" style="font-size: 500px; position: absolute; top: 50px; left: 40px;">O(<span class="red">1</span>)</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/198">

<div class="notes">
<p>So recently I added the hash_routes plugin to Roda, which combines the O(1) routing of the static_routing plugin with the ability to operate on a request at any point during routing.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes
Roda.hash_routes do
  on 'foo' do |r|
    # /foo branch
    r.hash_routes
  end
  is 'foo/bar' do |r|
    # /foo/bar path
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/199">

<div class="notes">
<p>You call the hash_routes class method with a block that looks similar to a standard Roda routing block. In this case, hash_routes is called without an argument, so the block given will set routes in the default namespace.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes
Roda.<b>hash_routes</b> do
  on 'foo' do |r|
    # /foo branch
    r.hash_routes
  end
  is 'foo/bar' do |r|
    # /foo/bar path
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/200">

<div class="notes">
<p>Inside the block, you use the on method to match branches, like Roda&#x2019;s standard branch matching.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes
Roda.hash_routes do
  <b>on 'foo'</b> do |r|
    # /foo branch
    r.hash_routes
  end
  is 'foo/bar' do |r|
    # /foo/bar path
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/201">

<div class="notes">
<p>Inside the block, you use the is method to match full paths, like Roda&#x2019;s standard path matching. So the hash_routes plugin should feel natural to most Roda users, even though under the hood it operates differently, with O(1) dispatching to each of the routes inside the hash_routes block .</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes
Roda.hash_routes do
  on 'foo' do |r|
    # /foo branch
    r.hash_routes
  end
  <b>is 'foo/bar'</b> do |r|
    # /foo/bar path
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/202">

<div class="notes">
<p>Using the hash_routes plugin keeps the primary advantage of Roda, which is the ability to operate on requests at any point during routing.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/203">

<div class="notes">
<p>Let&#x2019;s say the path we are trying to route is /foo/123/bar. I think most applications have routes like this, combining static segments such as foo and bar and dynamic segments such as the 123, where 123 is the id of the specific foo you are requesting.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/foo/123/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/204">

<div class="notes">
<p>The main route block calls the r.hash_routes method without an argument, which will perform an O(1) dispatch to the matching route in the default namespace, if such a route exists.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  <b>r.hash_routes</b>
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/foo/123/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/205">

<div class="notes">
<p>Because the first segment in the request path is foo, the r.hash_routes call will dispatch to the block specified by the on foo call here.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  <b>on 'foo'</b> do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/foo/123/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/206">

<div class="notes">
<p>That on foo call will extract the foo segment from the path, leaving the remaining path as /123/bar.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"<b>/123/bar</b>"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/207">

<div class="notes">
<p>The on foo call will yield the request to this block, which operates like a standard Roda routing tree. You can operate on the request at any point inside this block.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
<b class="block">    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end</b>
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/123/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/208">

<div class="notes">
<p>The r.on Integer call here</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    <b>r.on Integer</b> do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/123/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/209">

<div class="notes">
<p>will extract the 123 segment from the remaining path, leaving the remaining path as /bar.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"<b>/bar</b>"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/210">

<div class="notes">
<p>It will yield the integer 123 to the block.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |<b>id</b>|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/211">

<div class="notes">
<p>We can look up the foo object with id 123, and store it in an instance variable.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      <b>@foo = Foo[id]</b>
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/212">

<div class="notes">
<p>Then the r.hash_routes method is called with the symbol :foo, which will perform an O(1) dispatch to the matching route in the foo namespace, if such a route exists. The @foo instance variable you set in the line above will be available for all routes in the :foo namespace to use. We assume one of the routes in the :foo namespace will be bar.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      <b>r.hash_routes(:foo)</b>
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre><pre class="sh_ruby" style="position: absolute; top: 60px; left: 450px; font-size: 80px; margin-top: 400px; border: 3px dotted #00005B; padding: 10px;"><code>"/bar"
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/213">

<div class="notes">
<p>This approach does add a little complexity compared to Roda&#x2019;s standard routing, but I think it is the most scalable design. It allows O(1) routing performance at each level of the routing tree, and still supports the ability to operate on requests at any point during routing, which is the main reason Roda applications tend to be simpler that applications developed in other frameworks.|In this example, we saw how hashes can be used to improve performance.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>Roda.plugin :hash_routes

Roda.hash_routes do
  on 'foo' do |r|
    r.on Integer do |id|
      @foo = Foo[id]
      r.hash_routes(:foo)
    end
  end
end

Roda.route do |r|
  r.hash_routes
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/214">

<div class="notes">
<p>Anytime you are repeatedly performing the same computation on the same inputs, using hashes to introduce caching can also yield large performance improvements.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:50px; left: 260px;">Cache</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 180px; left: 340px;">when</h1><h1 class="red" style="font-size: 200px; position: absolute; top:210px; left: 210px;">Possible</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none">
  <div class="content " ref="slides/slides/215">

<div class="notes">
<p>In my experience, introducing caching has the highest ratio of percentage increase in performance to lines of code changed.</p>
</div>
<h1 class="blue" style="font-size: 80px; position: absolute; top:170px; left: 150px;">% Increase in Performance</h1><hr class="red" style="font-size: 100px; position: absolute; top: 250px; left: 120px; width: 1040px; border: 10px solid #5E0000;"><hr><h1 class="blue" style="font-size: 80px; position: absolute; top:350px; left: 210px;">Lines of Code Changed</h1></hr>
</hr>
</div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/216">

<div class="notes">
<p>I was able to dramatically improve performance in Sequel by adding caching to the literalization of symbols. Sequel uses Ruby symbols to represent SQL identifiers, such as table names and column names.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:60px; left: 95px;">Sequel</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 180px; left: 200px;">Symbol</h1><h1 class="red" style="font-size: 150px; position: absolute; top:300px; left: 230px;">Literalization</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/217">

<div class="notes">
<p>The literalization process in Sequel takes a symbol as an argument</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 60px;"><code>
:column_name
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/218">

<div class="notes">
<p>and adds the literalized version of the symbol to the SQL being generated. How symbols are literalized depends on which database is being used, and how Sequel is configured.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 60px;"><code>
:column_name
<b># =&gt; '"column_name"'</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/219">

<div class="notes">
<p>One of the reasons that literalizing symbols was slow in older versions of Sequel is that Sequel used special handling for symbols like this, allowing you to embed table names and column names in the same symbol.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 60px;"><code>
:column_name
# =&gt; '"column_name"'

<b>:table_name__column_name</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/220">

<div class="notes">
<p>Sequel would split this symbol into an SQL qualified identifier with a table name and column name.</p>
</div>
<pre class="sh_ruby" style="font-size: 50px; margin-top: 60px;"><code>
:column_name
# =&gt; '"column_name"'

:table_name__column_name
<b># =&gt; '"table_name"."column_name"'</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/221">

<div class="notes">
<p>This required running regular expressions on all symbols to determine if they should be split, using this code. This feature is no longer on by default, but it is still supported for backwards compatibility.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.split_symbol(sym)

    v = case s = sym.to_s
    when /\A((?:(?!__).)+)__((?:(?!___).)+)___(.+)\z/
      [$1.freeze, $2.freeze, $3.freeze].freeze
    when /\A((?:(?!___).)+)___(.+)\z/
      [nil, $1.freeze, $2.freeze].freeze
    when /\A((?:(?!__).)+)__(.+)\z/
      [$1.freeze, $2.freeze, nil].freeze
    else
      [nil, s.freeze, nil].freeze
    end


    v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/222">

<div class="notes">
<p>Sequel used to spend almost half of the time generating SQL in this code. Because almost all applications use a fixed set of table names and column names, this was a natural place to introduce caching.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>
def self.split_symbol(sym)

<b class="block">    v = case s = sym.to_s
    when /\A((?:(?!__).)+)__((?:(?!___).)+)___(.+)\z/
      [$1.freeze, $2.freeze, $3.freeze].freeze
    when /\A((?:(?!___).)+)___(.+)\z/
      [nil, $1.freeze, $2.freeze].freeze
    when /\A((?:(?!__).)+)__(.+)\z/
      [$1.freeze, $2.freeze, nil].freeze
    else
      [nil, s.freeze, nil].freeze
    end</b>


    v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/223">

<div class="notes">
<p>We start by creating a hash for the cache.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code><b>SPLIT_SYMBOL_CACHE = {}</b>
def self.split_symbol(sym)

    v = case s = sym.to_s
    when /\A((?:(?!__).)+)__((?:(?!___).)+)___(.+)\z/
      [$1.freeze, $2.freeze, $3.freeze].freeze
    when /\A((?:(?!___).)+)___(.+)\z/
      [nil, $1.freeze, $2.freeze].freeze
    when /\A((?:(?!__).)+)__(.+)\z/
      [$1.freeze, $2.freeze, nil].freeze
    else
      [nil, s.freeze, nil].freeze
    end


    v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/224">

<div class="notes">
<p>First we modify the code to check if the symbol is already in the cache. If so, we use the already computed value.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>SPLIT_SYMBOL_CACHE = {}
def self.split_symbol(sym)
  unless <b>v = Sequel.synchronize{SPLIT_SYMBOL_CACHE[sym]}</b>
    v = case s = sym.to_s
    when /\A((?:(?!__).)+)__((?:(?!___).)+)___(.+)\z/
      [$1.freeze, $2.freeze, $3.freeze].freeze
    when /\A((?:(?!___).)+)___(.+)\z/
      [nil, $1.freeze, $2.freeze].freeze
    when /\A((?:(?!__).)+)__(.+)\z/
      [$1.freeze, $2.freeze, nil].freeze
    else
      [nil, s.freeze, nil].freeze
    end

  end
  v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/225">

<div class="notes">
<p>Finally, if this is a new symbol not in the cache, after performing the computation, we need to store the computed value in the hash. Adding caching sped up this method over 10x, which sped up the generation of SQL for common datasets by up to 80%.</p>
</div>
<pre class="sh_ruby" style="font-size: 32px; margin-top: 10px;"><code>SPLIT_SYMBOL_CACHE = {}
def self.split_symbol(sym)
  unless v = Sequel.synchronize{SPLIT_SYMBOL_CACHE[sym]}
    v = case s = sym.to_s
    when /\A((?:(?!__).)+)__((?:(?!___).)+)___(.+)\z/
      [$1.freeze, $2.freeze, $3.freeze].freeze
    when /\A((?:(?!___).)+)___(.+)\z/
      [nil, $1.freeze, $2.freeze].freeze
    when /\A((?:(?!__).)+)__(.+)\z/
      [$1.freeze, $2.freeze, nil].freeze
    else
      [nil, s.freeze, nil].freeze
    end
    <b>Sequel.synchronize{SPLIT_SYMBOL_CACHE[sym] = v}</b>
  end
  v
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/226">

<div class="notes">
<p>One way to make it easier to use caching to improve performance is to use an approach I call globally frozen, locally mutable. With this approach, you freeze your global state that persists across requests, such as classes and other objects that can be accessed by multiple threads. However, local objects that are instantiated per request and not kept after the request remain mutable for ease of use.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top:60px; left: 95px;">Globally</h1><h1 class="red" style="font-size: 150px; position: absolute; top: 180px; left: 200px;">Frozen,</h1><h1 class="blue" style="font-size: 150px; position: absolute; top:300px; left: 410px;">Locally</h1><h1 class="red" style="font-size: 150px; position: absolute; top:420px; left: 430px;">Mutable</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/227">

<div class="notes">
<p>The main reason I use this approach is for improved reliability, as this approach makes it much more difficult to introduce thread safety issues in applications.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top: 75px; left: 80px;">Improved</h1><h1 class="blue" style="font-size: 150px; position: absolute; top:200px; left: 310px;">Reliability</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/228">

<div class="notes">
<p>But this approach can lead to improved performance. Because frozen objects cannot be modified, it means that they can be easily cached.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top: 75px; left: 80px;">Improved</h1><h1 class="blue" style="font-size: 150px; position: absolute; top:200px; left: 310px;">Performance</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/229">

<div class="notes">
<p>With this approach, frozen does not mean that all parts of objects are immutable. While that would be fine for reliability, it would not be great for performance.</p>
</div>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 225px; left: 80px;">Frozen</h1><h1 class="red" style="font-size: 200px; position: absolute; top: 175px; left: 450px;">!=</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 225px; left: 690px;">Immutable</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/230">

<div class="notes">
<p>To make this approach improve performance, you keep the object&#x2019;s state immutable, but you allow the object to contain mutable hashes that are used for caching. In general you want to make sure these caches are thread safe, so access to them should be protected by a mutex.</p>
</div>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 225px; left: 80px;">Frozen</h1><h1 class="red" style="font-size: 200px; position: absolute; top: 175px; left: 430px;">==</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 35px; left: 690px;">Immutable</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 125px; left: 800px;">State</h1><h1 class="red" style="font-size: 100px; position: absolute; top: 225px; left: 870px;">+</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 325px; left: 730px;">Mutable</h1><h1 class="blue" style="font-size: 100px; position: absolute; top: 415px; left: 780px;">Cache</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/231">

<div class="notes">
<p>Here is the initialize method for Sequel::Dataset.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def initialize(db)
  @db = db
  @opts = OPTS
  @cache = {}
  freeze
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/232">

<div class="notes">
<p>Sequel datasets keep their state in a frozen hash called opts.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def initialize(db)
  @db = db
  <b>@opts = OPTS</b>
  @cache = {}
  freeze
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/233">

<div class="notes">
<p>Each dataset has a cache that is not frozen. Access to this cache is performed through private methods that use a mutex to ensure thread safe access to the cache.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def initialize(db)
  @db = db
  @opts = OPTS
  <b>@cache = {}</b>
  freeze
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/234">

<div class="notes">
<p>Then the object itself is frozen, ensuring that the only part of the object that can be modifed is the cache.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def initialize(db)
  @db = db
  @opts = OPTS
  @cache = {}
  <b>freeze</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/235">

<div class="notes">
<p>Sequel datasets use the cache extensively to improve performance. One case where there was an immediate substantial increase in performance is when I started caching the generated SQL for datasets.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def select_sql
  if sql = cache_get(:_select_sql)
    return sql
  end

  sql = String.new
  # ...
  
  cache_set(:_select_sql, sql) if cache_sql?
  sql
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/236">

<div class="notes">
<p>When a dataset is asked to generate the SQL query, it first checks if the SQL is already cached.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def select_sql
  if <b>sql = cache_get(:_select_sql)</b>
    return sql
  end

  sql = String.new
  # ...
  
  cache_set(:_select_sql, sql) if cache_sql?
  sql
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/237">

<div class="notes">
<p>If so, it returns the cached SQL, which even for the simplest datasets, is over 6x faster than regenerating the SQL.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def select_sql
  if sql = cache_get(:_select_sql)
    <b>return sql</b>
  end

  sql = String.new
  # ...
  
  cache_set(:_select_sql, sql) if cache_sql?
  sql
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/238">

<div class="notes">
<p>If the SQL is not cached, then Sequel must generate the SQL for the dataset.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def select_sql
  if sql = cache_get(:_select_sql)
    return sql
  end

<b class="block">  sql = String.new
  # ...</b>
  
  cache_set(:_select_sql, sql) if cache_sql?
  sql
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/239">

<div class="notes">
<p>After Sequel has generated the SQL, it can determine whether or not is is possible to cache the SQL for the dataset. In some cases, it is not possible to cache the SQL, because the SQL could change depending on runtime state.|This is another example of separating the common case from the uncommon case when optimizing. In the common case, it is possible to cache the SQL, and doing so is much faster. In the uncommon case, caching is not possible, in which case checking the cache adds little overhead compared to generating the SQL.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def select_sql
  if sql = cache_get(:_select_sql)
    return sql
  end

  sql = String.new
  # ...
  
  cache_set(:_select_sql, sql) if <b>cache_sql?</b>
  sql
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/240">

<div class="notes">
<p>Assuming this is the common case, the generated SQL is stored in the cache, so that the next call to generate the SQL for this dataset will be able to benefit from the caching.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def select_sql
  if sql = cache_get(:_select_sql)
    return sql
  end

  sql = String.new
  # ...
  
  <b>cache_set(:_select_sql, sql)</b> if cache_sql?
  sql
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/241">

<div class="notes">
<p>Another example of how Sequel uses caching is for caching intermediate datasets. Sequel datasets have a single_record method, which returns the first row in the dataset. This is how the single_record method looked a couple years ago, before I added caching to datasets.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def single_record
  clone(:limit=&gt;1).single_record!
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/242">

<div class="notes">
<p>This method first had to create a clone of the dataset to limit the dataset to one row, which added a little bit of overhead by itself.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def single_record
  <b>clone(:limit=&gt;1)</b>.single_record!
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/243">

<div class="notes">
<p>After caching was added to datasets, I changed this to call a method named single_record_ds.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def single_record
  <b>_single_record_ds</b>.single_record!
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/244">

<div class="notes">
<p>The single_record_ds method would check the cache and see if there was a cached dataset that was already limited to one row. If so, it would return the cached dataset, instead of allocating another dataset.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def single_record
  _single_record_ds.single_record!
end

def _single_record_ds
  <b>cached_dataset(:_single_record_ds)</b> do
    clone(:limit=&gt;1)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/245">

<div class="notes">
<p>If there was no entry in the cache, it would call the block to get the dataset, and it would store the dataset the block returned in the cache.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def single_record
  _single_record_ds.single_record!
end

def _single_record_ds
  cached_dataset(:_single_record_ds) do
    <b>clone(:limit=&gt;1)</b>
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/246">

<div class="notes">
<p>After getting the dataset that has been limited to one row, single_record! is called to return the row. Assuming the dataset is in the cache, this turns out to be a large optimization. While saving the dataset allocation is only a small optimization, because the returned dataset will already have cached the generated SQL, this allows Sequel to skip the expensive step of generating the SQL, which improved performance of this method by over 30%.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>
def single_record
  _single_record_ds.<b>single_record!</b>
end

def _single_record_ds
  cached_dataset(:_single_record_ds) do
    clone(:limit=&gt;1)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/247">

<div class="notes">
<p>In addition to using this approach to optimize many of Sequel&#x2019;s internal methods, Sequel also automatically uses this optimization in metaprogramming methods it exposes to the user.</p>
</div>
<h1 class="blue" style="font-size: 150px; position: absolute; top: 175px; left: 80px;">Optimization</h1><h1 class="red" style="font-size: 150px; position: absolute; top:300px; left: 260px;">Through</h1><h1 class="blue" style="font-size: 120px; position: absolute; top:420px; left: 160px;">Metaprogramming</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/248">

<div class="notes">
<p>For many years, Sequel has supported the ability for model classes to add methods to the model&#x2019;s dataset.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    def by_name
      order(:name)
    end

    def released
      where(released: true)
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/249">

<div class="notes">
<p>The dataset_module class method accepts a block, and module_evals the block in the context of a subclass of Module</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  <b>dataset_module</b> do
    def by_name
      order(:name)
    end

    def released
      where(released: true)
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/250">

<div class="notes">
<p>This allows you to define methods inside the block, such as by_name to order the dataset by name,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
<b class="block">    def by_name
      order(:name)
    end</b>

    def released
      where(released: true)
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/251">

<div class="notes">
<p>and released to filter the dataset to only include albums that have been released.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    def by_name
      order(:name)
    end

<b class="block">    def released
      where(released: true)
    end</b>
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/252">

<div class="notes">
<p>Once these methods are defined inside the dataset_module block, you can simplify code like this.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    def by_name
      order(:name)
    end

    def released
      where(released: true)
    end
  end
end

<b>Album.where(released: true).order(:name).first</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/253">

<div class="notes">
<p>You can replace the where call with the released method,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    def by_name
      order(:name)
    end

    def released
      where(released: true)
    end
  end
end

Album.<b>released</b>.order(:name).first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/254">

<div class="notes">
<p>and the order call with the by_name method. Now with older versions of Sequel, you would use this approach to make the code easier to read, and to DRY up code. However, it did not improve performance.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    def by_name
      order(:name)
    end

    def released
      where(released: true)
    end
  end
end

Album.released.<b>by_name</b>.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/255">

<div class="notes">
<p>After adding dataset caching, I developed a way to dramatically speed up this code.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    def by_name
      order(:name)
    end

    def released
      where(released: true)
    end
  end
end

<b>Album.released.by_name.first</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/256">

<div class="notes">
<p>I added metaprogramming methods inside the dataset_module block. Inside of defining the by_name method with def,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
<b class="block">    def by_name
      order(:name)
    end</b>

    def released
      where(released: true)
    end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/257">

<div class="notes">
<p>You call a method named order, which will define a method that calls the order method.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    <b>order</b> :by_name, :name # def 
                          #   <b>order</b>()
                          # end

    def released
      where(released: true)
    end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/258">

<div class="notes">
<p>The first argument to order is the method name to define, in this case by_name.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order <b>:by_name</b>, :name # def <b>by_name</b>
                          #   order()
                          # end

    def released
      where(released: true)
    end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/259">

<div class="notes">
<p>All remaining arguments are passed to the order call.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, <b>:name</b> # def by_name
                          #   order(<b>:name</b>)
                          # end

    def released
      where(released: true)
    end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/260">

<div class="notes">
<p>Similarly, you can define the released method by calling the where method with released as the first argument, and the hash with released true as the second argument.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, :name # def by_name
                          #   order(:name)
                          # end
    <b>where :released, released: true</b>
    # def released
    #   where(released: true)
    # end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/261">

<div class="notes">
<p>The performance advantage of using these metaprogramming methods,</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    <b>order</b> :by_name, :name # def by_name
                          #   order(:name)
                          # end
    <b>where</b> :released, released: true
    # def released
    #   where(released: true)
    # end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/262">

<div class="notes">
<p>is that these methods define methods that support caching automatically.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, :name # def by_name
                          #   <b>cache</b>{order(:name)}
                          # end
    where :released, released: true
    # def released
    #   <b>cache</b>{where(released: true)}
    # end
  end
end

Album.released.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/263">

<div class="notes">
<p>So the first time you call Album.released, you have to allocate a new dataset. But all subsequent calls return a cached dataset.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, :name # def by_name
                          #   cache{order(:name)}
                          # end
    where :released, released: true
    # def released
    #   cache{where(released: true)}
    # end
  end
end

Album.<b>released</b>.by_name.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/264">

<div class="notes">
<p>The first time you call by_name on that dataset, you have to allocate a new dataset. But all subsequent calls return a cached dataset.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, :name # def by_name
                          #   cache{order(:name)}
                          # end
    where :released, released: true
    # def released
    #   cache{where(released: true)}
    # end
  end
end

Album.released.<b>by_name</b>.first
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/265">

<div class="notes">
<p>The first time you call first on that dataset, you have to generate the SQL. But all subsequent calls use the cached SQL.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, :name # def by_name
                          #   cache{order(:name)}
                          # end
    where :released, released: true
    # def released
    #   cache{where(released: true)}
    # end
  end
end

Album.released.by_name.<b>first</b>
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/266">

<div class="notes">
<p>If you run this 100 times, due to caching, you only allocate 3 datasets and only have to generate the SQL once. This is way faster that the uncached approach, which would allocate 300 datasets and generate the SQL 100 times.</p>
</div>
<pre class="sh_ruby" style="font-size: 40px; margin-top: 10px;"><code>class Album &lt; Sequel::Model
  dataset_module do
    order :by_name, :name # def by_name
                          #   cache{order(:name)}
                          # end
    where :released, released: true
    # def released
    #   cache{where(released: true)}
    # end
  end
end

<b>100.times</b> { Album.released.by_name.first }
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/267">

<div class="notes">
<p>I used caching and a few other techniques I have discussed in this presentation while optimizing Roda&#x2019;s string matching.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:60px; left: 95px;">Roda</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 180px; left: 200px;">String</h1><h1 class="red" style="font-size: 150px; position: absolute; top:300px; left: 410px;">Matching</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/268">

<div class="notes">
<p>Roda was forked from another web framework named Cuba. At a point shortly after forking, this was the code Roda used to determine if a given string matched the next segment in the request path.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A\/(#{pattern})(\/|\z)/)
 
  return false unless matchdata
 
  path, *vars = matchdata.captures
 
  env[SCRIPT_NAME] += "/#{path}"
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/269">

<div class="notes">
<p>The match_string method should return whether the next segment in the path matches the given string.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def <b>match_string</b>(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A\/(#{pattern})(\/|\z)/)
 
  return false unless matchdata
 
  path, *vars = matchdata.captures
 
  env[SCRIPT_NAME] += "/#{path}"
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/270">

<div class="notes">
<p>The consume method is more general, matching regular expressions to the request path, and handling any captures so they can be yielded to the appropriate block.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def <b>consume(pattern)</b>
  matchdata = env[PATH_INFO].match(/\A\/(#{pattern})(\/|\z)/)
 
  return false unless matchdata
 
  path, *vars = matchdata.captures
 
  env[SCRIPT_NAME] += "/#{path}"
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/271">

<div class="notes">
<p>My first focus was to avoid as many allocations as I could in this code.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A\/(#{pattern})(\/|\z)/)
 
  return false unless matchdata
 
<b class="block">  path, *vars = matchdata.captures
 
  env[SCRIPT_NAME] += "/#{path}"
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"</b>
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/272">

<div class="notes">
<p>The first change was modifying the first capture in the regular expression to include the preceding slash.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A<b>(\/(?:#{pattern}))</b>(\/|\z)/)
 
  return false unless matchdata
 
  path, *vars = matchdata.captures
 
  env[SCRIPT_NAME] += "/#{path}"
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/273">

<div class="notes">
<p>We avoid the extra array allocation for the captures.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A(\/(?:#{pattern}))(\/|\z)/)
 
  return false unless matchdata
 
  <b>vars</b> = matchdata.captures
 
  env[SCRIPT_NAME] += "/#{path}"
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/274">

<div class="notes">
<p>Instead shifting off the first element of the array, which is the path with the preceding slash, which avoids the additional string allocation.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A(\/(?:#{pattern}))(\/|\z)/)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += <b>vars.shift</b>
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/275">

<div class="notes">
<p>The next change was to modify the regular expression to use a positive lookahead assertion instead of a capture to determine if the pattern was at the end of a segment.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A(\/(?:#{pattern}))(<b>?=</b>\/|\z)/)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = "#{vars.pop}#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/276">

<div class="notes">
<p>This made it so we no longer need to pop the last element off the array of captured variables.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A(\/(?:#{pattern}))(?=\/|\z)/)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = "<b>#{vars.pop}</b>#{matchdata.post_match}"
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/277">

<div class="notes">
<p>and we could avoid the allocation of the additional string by using post_match directly.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A(\/(?:#{pattern}))(?=\/|\z)/)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = <b>matchdata.post_match</b>
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/278">

<div class="notes">
<p>Some profiling I did showed that generating a new regular expression every time consume was called was taking a large portion of the total time spent.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(Regexp.escape(str))
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(<b>/\A(\/(?:#{pattern}))(?=\/|\z)/</b>)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = matchdata.post_match
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/279">

<div class="notes">
<p>As almost all strings used for routing are static, I was able to dramatically speed up the match_string method by caching the generated regular expressions.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(<b>self.class.cached_matcher(str){Regexp.escape(str)}</b>)
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(/\A(\/(?:#{pattern}))(?=\/|\z)/)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = matchdata.post_match
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/280">

<div class="notes">
<p>With a corresponding change to the consume method to use the regular expression directly instead of generating a new regular expression. Note that I could only make this behavior change to consume because consume was a private method.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(self.class.cached_matcher(str){Regexp.escape(str)})
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(<b>pattern</b>)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = matchdata.post_match
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/281">

<div class="notes">
<p>That brings me to another optimization principle, which is to keep most methods private. Only make a method public if it needs to be public. If a method is private, you are free to change its API to improve performance. Making a method public limits your optimization options.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:160px; left: 395px;">Most</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 280px; left: 500px;">Methods</h1><h1 class="red" style="font-size: 150px; position: absolute; top:400px; left: 710px;">Private</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/282">

<div class="notes">
<p>So this is what Roda&#x2019;s string matching code looked like in Roda 1.0.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(self.class.cached_matcher(str){Regexp.escape(str)})
end

def consume(pattern)
  matchdata = env[PATH_INFO].match(pattern)
 
  return false unless matchdata
 
  vars = matchdata.captures
 
  env[SCRIPT_NAME] += vars.shift
  env[PATH_INFO] = matchdata.post_match
 
  captures.push(*vars)
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/283">

<div class="notes">
<p>The consuming of patterns was further optimized before the release of Roda 2, avoiding the need to modify the rack environment completely, or do any operations on the array of captures.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(self.class.cached_matcher(str){Regexp.escape(str)})
end

def consume(pattern)
<b class="block">  if matchdata = remaining_path.match(pattern)
    @remaining_path = matchdata.post_match
    @captures.concat(matchdata.captures)
  end</b>
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/284">

<div class="notes">
<p>Instead of using the rack environment to store the remaining path, I started storing the remaining path in an instance variable, and then during matching, we just need to update the remaining path instance variable with the part of the string after the match. String matching was further optimized later using another general optimization principle.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  consume(self.class.cached_matcher(str){Regexp.escape(str)})
end

def consume(pattern)
  if matchdata = remaining_path.match(pattern)
    <b>@remaining_path = matchdata.post_match</b>
    @captures.concat(matchdata.captures)
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/285">

<div class="notes">
<p>Which is to prefer string operations to regular expression operations in cases where you can perform the same operation, as string operations are faster.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:150px; left: 160px;">Prefer</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 280px; left: 240px;">String</h1><h1 class="red" style="font-size: 100px; position: absolute; top: 390px; left: 340px;">over</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 450px; left: 240px;">Regexp</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/286">

<div class="notes">
<p>So in Roda 3.0, the string matching code looked like this.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case rp[last]
    when "/"
      @remaining_path = rp[last, rp.length]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/287">

<div class="notes">
<p>We start by checking if the remaining path starts with the string prefixed with a slash.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if <b>rp.start_with?("/#{str}")</b>
    last = str.length + 1
    case rp[last]
    when "/"
      @remaining_path = rp[last, rp.length]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/288">

<div class="notes">
<p>If so, we check next character in the string.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case <b>rp[last]</b>
    when "/"
      @remaining_path = rp[last, rp.length]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/289">

<div class="notes">
<p>If the next character in the string is a slash, then we have matched a whole segment.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case rp[last]
    when <b>"/"</b>
      @remaining_path = rp[last, rp.length]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/290">

<div class="notes">
<p>In that case, we update the remaining path to remove the segment we matched.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case rp[last]
    when "/"
      <b>@remaining_path = rp[last, rp.length]</b>
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/291">

<div class="notes">
<p>If the last character is nil, then we have matched the final segment in the path</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case rp[last]
    when "/"
      @remaining_path = rp[last, rp.length]
    when <b>nil</b>
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/292">

<div class="notes">
<p>In that case, we set the remaining path to the empty string.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case rp[last]
    when "/"
      @remaining_path = rp[last, rp.length]
    when nil
      <b>@remaining_path = ""</b>
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/293">

<div class="notes">
<p>If the match is some other character, that means we only matched a partial segment and not a whole segment, so it isn&#x2019;t a true match. In that case, we return nil without updating the remaining path. We can omit the else clause in this case, as the behavior is the same.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?("/#{str}")
    last = str.length + 1
    case rp[last]
    when "/"
      @remaining_path = rp[last, rp.length]
    when nil
      @remaining_path = ""
<b class="block">#   else
#     nil</b>
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/294">

<div class="notes">
<p>The main remaining issue with this code are these two string allocations. Eliminating them would make the code even faster.</p>
</div>
<pre class="sh_ruby" style="font-size: 30px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  if rp.start_with?(<b>"/#{str}"</b>)
    last = str.length + 1
    case <b>rp[last]</b>
    when "/"
      @remaining_path = rp[last, rp.length]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/295">

<div class="notes">
<p>So I recently did that.</p>
</div>
<pre class="sh_ruby" style="font-size: 22px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  length = str.length

  match = case rp.rindex(str, length)
  when nil
    return
  when 1
    rp.getbyte(0) == 47
  else
    length == 0 &amp;&amp; rp.getbyte(0) == 47
  end

  if match 
    length += 1
    case rp.getbyte(length)
    when 47
      @remaining_path = rp[length, 100000000]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/296">

<div class="notes">
<p>I replaced the start_with call with an rindex call starting where we expect the end of the segment to be. This avoids allocating a new string for the segment preceded by a slash.</p>
</div>
<pre class="sh_ruby" style="font-size: 22px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  length = str.length

  match = case <b>rp.rindex(str, length)</b>
  when nil
    return
  when 1
    rp.getbyte(0) == 47
  else
    length == 0 &amp;&amp; rp.getbyte(0) == 47
  end

  if match 
    length += 1
    case rp.getbyte(length)
    when 47
      @remaining_path = rp[length, 100000000]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/297">

<div class="notes">
<p>When checking for slashes, instead of retrieving the character and comparing it to the slash string, I call getbyte, and compare the result to the ASCII code for slash, which is 47. This is another general optimization principle,</p>
</div>
<pre class="sh_ruby" style="font-size: 22px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  length = str.length

  match = case rp.rindex(str, length)
  when nil
    return
  when 1
    <b>rp.getbyte(0) == 47</b>
  else
    length == 0 &amp;&amp; <b>rp.getbyte(0) == 47</b>
  end

  if match 
    length += 1
    case <b>rp.getbyte(length)</b>
    when <b>47</b>
      @remaining_path = rp[length, 100000000]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/298">

<div class="notes">
<p>Which is to prefer integer operations to string operations in cases where you can perform the same operation, as integer operations are faster.</p>
</div>
<h1 class="red" style="font-size: 150px; position: absolute; top:150px; left: 160px;">Prefer</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 280px; left: 240px;">Integer</h1><h1 class="red" style="font-size: 100px; position: absolute; top: 390px; left: 310px;">over</h1><h1 class="blue" style="font-size: 150px; position: absolute; top: 470px; left: 240px;">String</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/299">

<div class="notes">
<p>I make the first when clause in first case statement handle the failure case, since that is more common than the success case when doing path matching.</p>
</div>
<pre class="sh_ruby" style="font-size: 22px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  length = str.length

  match = case rp.rindex(str, length)
<b class="block">  when nil
    return</b>
  when 1
    rp.getbyte(0) == 47
  else
    length == 0 &amp;&amp; rp.getbyte(0) == 47
  end

  if match 
    length += 1
    case rp.getbyte(length)
    when 47
      @remaining_path = rp[length, 100000000]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/300">

<div class="notes">
<p>I also cheat here and don&#x2019;t use a method call to determine the proper end of the string, instead just using a number larger than any reasonable path length, since I want all remaining characters in the string.</p>
</div>
<pre class="sh_ruby" style="font-size: 22px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  length = str.length

  match = case rp.rindex(str, length)
  when nil
    return
  when 1
    rp.getbyte(0) == 47
  else
    length == 0 &amp;&amp; rp.getbyte(0) == 47
  end

  if match 
    length += 1
    case rp.getbyte(length)
    when 47
      @remaining_path = rp[length, <b>100000000</b>]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/301">

<div class="notes">
<p>All told, this is 10 to 20 percent faster than the approach used in Roda 3.0, and many times faster than the code before optimization.</p>
</div>
<pre class="sh_ruby" style="font-size: 22px; margin-top: 10px;"><code>
def match_string(str)
  rp = @remaining_path
  length = str.length

  match = case rp.rindex(str, length)
  when nil
    return
  when 1
    rp.getbyte(0) == 47
  else
    length == 0 &amp;&amp; rp.getbyte(0) == 47
  end

  if match 
    length += 1
    case rp.getbyte(length)
    when 47
      @remaining_path = rp[length, 100000000]
    when nil
      @remaining_path = ""
    end
  end
end
</code></pre></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/302">

<div class="notes">
<p>It is important to remember that optimization should be one of the last things you do.</p>
</div>
<h1 class="blue" style="font-size: 120px; position: absolute; top: 75px; left: 120px;">Optimization</h1><h1 class="red" style="font-size: 80px; position: absolute; top: 180px; left: 160px;">Comes</h1><h1 class="blue" style="font-size: 250px; position: absolute; top: 160px; left: 60px;">Last</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/303">

<div class="notes">
<p>First you make it work.</p>
</div>
<h1 class="blue" style="font-size: 300px; text-align: center; margin-top: 200px;">Work</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/304">

<div class="notes">
<p>Then you make it correct.</p>
</div>
<h1 class="blue" style="font-size: 300px; text-align: center; margin-top: 200px;">Correct</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/305">

<div class="notes">
<p>Then you make it fun. This is Ruby after all, you gotta make it fun.</p>
</div>
<h1 class="blue" style="font-size: 400px; text-align: center; margin-top: 200px;">Fun<span class="red">!</span>
</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/306">

<div class="notes">
<p>Then you make it fast. Hopefully this presentation has helped provide you some useful techniques for making it fast.</p>
</div>
<h1 class="red" style="font-size: 400px; text-align: center; margin-top: 200px;">Fast</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/307">

<div class="notes">
<p>If I appear to be some kind of optimization guru, remember that appearances are often deceiving.</p>
</div>
<h1 class="blue" style="font-size: 120px; position: absolute; top: 175px; left: 20px;">Deceiving</h1><h1 class="red" style="font-size: 120px; position: absolute; top: 280px; left: 460px;">Appearances</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/308">

<div class="notes">
<p>I am a programmer just like most of you. While I have experience working on optimizations, it is still mostly a process of trial and error for me. Many times haved I tried a new optimization approach, only to benchmark it after and discover that I made the performance worse. And that is OK, for I learned that something did not work, adding to my knowledge of approaches to avoid in the future. Then I just reverted the code and tried a different approach.</p>
</div>
<h1 class="blue" style="font-size: 120px; position: absolute; top: 255px; left: 160px;">Trial</h1><h1 class="red" style="font-size: 250px; position: absolute; top: 180px; left: 450px;">&amp;</h1><h1 class="blue" style="font-size: 120px; position: absolute; top: 255px; left: 680px;">Error</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/309">

<div class="notes">
<p>One great thing about optimization is it is usually easy to see if you succeeded or failed. You can use the benchmark or benchmark-ips libraries and see if your attempt at optimization improved the performance.</p>
</div>
<h1 class="blue mono" style="font-size: 150px; position: absolute; top: 200px; left: 50px;">benchmark</h1><h1 class="red mono" style="font-size: 150px; position: absolute; top: 350px; left: 50px;">benchmark-ips</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/310">

<div class="notes">
<p>If you aren&#x2019;t sure what part of your code to start optimizing, start by profiling the code. There are more options for this, such as ruby-prof, stackprof, rack-mini-profiler, and rbspy. Profiling allows you to find out what methods are taking the most time, which are usually the best places to start optimizing.</p>
</div>
<h1 class="blue mono" style="font-size: 100px; position: absolute; top: 100px; left: 50px;">ruby-prof</h1><h1 class="red mono" style="font-size: 100px; position: absolute; top: 220px; left: 50px;">stackprof</h1><h1 class="blue mono" style="font-size: 100px; position: absolute; top: 340px; left: 50px;">rack-mini-profiler</h1><h1 class="red mono" style="font-size: 100px; position: absolute; top: 460px; left: 50px;">rbspy</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/311">

<div class="notes">
<p>If you haven&#x2019;t tried to optimize code before, now is a great time to start. Optimization is within your power. You can do it.</p>
</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 55px; left: 260px;">You</h1><h1 class="red" style="font-size: 150px; position: absolute; top: 270px; left: 160px;">Can Do It!</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/312">

<div class="notes">
<p>For many years, we as a community have made it work.</p>
</div>
<h1 class="blue" style="font-size: 300px; text-align: center; margin-top: 200px;">Work</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/313">

<div class="notes">
<p>We have made it correct.</p>
</div>
<h1 class="blue" style="font-size: 300px; text-align: center; margin-top: 200px;">Correct</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/314">

<div class="notes">
<p>We have made it very fun.</p>
</div>
<h1 class="blue" style="font-size: 400px; text-align: center; margin-top: 200px;">Fun<span class="red">!</span>
</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/315">

<div class="notes">
<p>Now, let us all work together to improve the performance of Ruby libraries, and through them the performance of Ruby programs.</p>
</div>
<h1 class="red" style="font-size: 400px; text-align: center; margin-top: 200px;">Fast</h1></div>
</div><div id="slides/slides" class="slide " data-transition="none"><div class="content " ref="slides/slides/316">

<div class="notes">
<p>Together, let us usher in a new age of Ruby performance. We as a community can do it!</p>
</div>
<h1 class="red" style="font-size: 500px; text-align: center; margin-top: 100px;">Fast<span class="blue">!</span>
</h1></div>
</div><div id="slides/slides" class="slide bg-thankyou" data-transition="none"><div class="content bg-thankyou" ref="slides/slides/317">

<div class="notes">
<p>Kore de watashi no happyo wa owaridesu. Watashi no hanashi o kiite kurete arigato. (That concludes my presentation. Thank all of you for listening to me.)</p>
</div>
</div>
</div><div id="slides/slides" class="slide bg-questions" data-transition="none"><div class="content bg-questions" ref="slides/slides/318">

<div class="notes">
<p>I am sure many of you have questions, so please ask them now. Hazukashi garanaide, shitsumon shite kudasai. (Do not be shy, please ask a question.)</p>
</div>
</div>
</div><div id="slides/slides" class="slide credits" data-transition="none"><div class="content credits" ref="slides/slides/319">

<div class="notes">
<p>Photo credits</p>
</div>
<h1 style="text-align: center">Photo Credits</h1>
<p>Benchmark Graphs: TechEmpower</p>

<p>Thank You / Arigato : http://img02.deviantart.net/13c6/i/2011/267/7/f/arigato_gozaimasu_by_emmaprew-d4asmyu.jpg</p>

<p>Question Mark: https://pixabay.com/photos/question-mark-knowledge-question-3255118/</p>
</div>
</div>
</div>

</body>
</html>
