<!DOCTYPE html>

<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>The Second Oldest Bug</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>

  <link rel="stylesheet" href="./css/reset.css" type="text/css"/>

  <link type="text/css" href="./css/fg.menu.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/theme/ui.all.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/sh_style.css" rel="stylesheet" />
  <link type="text/css" href="./css/tipsy.css" rel="stylesheet" />

  <link rel="stylesheet" href="./css/showoff.css" type="text/css"/>

    <style type="text/css">
      @media screen {
        #preso, .slide {
          width: 1920px;
          height: 1080px;
        }
        #footer { width: 1901px; }
      }
    </style>

  <script type="text/javascript" src="./js/jquery-1.4.2.min.js"></script>
  <script type="text/javascript" src="./js/jquery.cycle.all.js"></script>
	<script type="text/javascript" src="./js/jquery-print.js"></script>
  <script type="text/javascript" src="./js/jquery.batchImageLoad.js"></script>
  <script type="text/javascript" src="./js/jquery.parsequery.min.js"></script>
  <script type="text/javascript" src="./js/jquery.doubletap-0.1.js"></script>
  <script type="text/javascript" src="./js/jquery.tipsy.js"></script>

  <script type="text/javascript" src="./js/fg.menu.js"></script>
  <script type="text/javascript" src="./js/showoff.js"></script>
  <script type="text/javascript" src="./js/jTypeWriter.js"> </script>
  <script type="text/javascript" src="./js/sh_main.min.js"></script>
  <script type="text/javascript" src="./js/core.js"></script>
  <script type="text/javascript" src="./js/showoffcore.js"></script>
  <script type="text/javascript" src="./js/coffee-script.js"></script>

      <script type="text/javascript" src="./js/sh_lang/sh_ruby.min.js"></script>
      <script type="text/javascript" src="./js/sh_lang/sh_c.min.js"></script>

    <link rel="stylesheet" href="./file/fonts.css" type="text/css"/>
    <link rel="stylesheet" href="./file/something.css" type="text/css"/>


  <script type="text/javascript">
  $(function(){
      if(!('slaveWindow' in window) && window.name !== 'toolbar' && $(window).width() < $(document).width()) {
        no_resize = true;
        $('body').css("zoom", ""+($(window).width()*100.0)/$(document).width()+"%");
        $('body').css("overflow-y", "auto");
        $('body').css("overflow-x", "hidden");
        $('#notesInfo').css("font-size", ""+$(document).width()*14.0/$(window).width()+"px");
        $('#notesInfo').css("line-height", ""+$(document).width()*20.0/$(window).width()+"px");
      }
      setupPreso(false, '.');
  });
  </script>

</head>

<body>

<div id="help">
  <table>
    <tr><td class="key">z, ?</td><td>toggle help (this)</td></tr>
    <tr><td class="key">space, &rarr;</td><td>next slide</td></tr>
    <tr><td class="key">shift-space, &larr;</td><td>previous slide</td></tr>
    <tr><td class="key">d</td><td>toggle debug mode</td></tr>
    <tr><td class="key">## &lt;ret&gt;</td><td>go to slide #</td></tr>
    <tr><td class="key">r</td><td>reload slides</td></tr>
    <tr><td class="key">n</td><td>toggle notes</td></tr>
  </table>
</div>

<div class="buttonNav">
  <input type="submit" onClick="prevStep();" value="prev"/>
  <input type="submit" onClick="nextStep();" value="next"/>
</div>

<div id="preso"><center>loading presentation...</center></div>
<div id="footer">
  <span id="notesInfo"></span>
  <img id="disconnected" src="/css/disconnected.png" />
</div>

<div id="slides" class="offscreen" style="display:none;">
<html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/1">

<div class="notes">Hello everyone. In this presentation, I will be discussing what was Ruby’s second oldest open bug, and how we fixed the bug in Ruby 3.3.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
<h1 class="blue" style="font-size: 108px; position: absolute; top: 762px; right: 90px; text-align: right;">
<span class="red">Ruby</span>Conf 2023</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/2">

<div class="notes">My name is Jeremy Evans. I am a Ruby committer who focuses on fixing bugs in Ruby.</div>

<p><img class="profile-pic" src="./file/jeremy.jpg" style="position: absolute; top: 292px; left: 246px;"></p>
<h1 class="red" style="font-size: 72px; position: absolute; top: 432px; left: 750px;">GitHub:  <span class="blue mono"> jeremyevans</span>
</h1>
<h1 class="red" style="font-size: 72px; position: absolute; top: 507px; left: 750px;">Twitter:  <span class="blue mono">@jeremyevans0</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/3">

<div class="notes">I am also the author of Polished Ruby Programming, which was published a couple years ago. This book is aimed at intermediate Ruby programmers and focuses on teaching principles of Ruby programming, as well as trade-offs to consider when making implementation decisions.</div>

<p><img src="./file/polished-ruby-programming-cover.png" style="position: absolute; top: 20px; left: 581px; height: 1031px; width: 822px;"></p>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/4">

<div class="notes">So, what is the second oldest bug that I am discussing?</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/5">

<div class="notes">I am referring to bug 4040, which has the subject "SystemStackError with Hash[*a] for Large _a_"</div>
<h1 class="red" style="font-size: 80px; position: absolute; top: 232px; left: 250px;">https://bugs.ruby-lang.org/issues/4040</h1>
<h1 class="blue" style="font-size: 80px; position: absolute; top: 432px; left: 125px;">SystemStackError with Hash[*a] for Large _a_</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/6">

<div class="notes">The reproduction code given in the bug report was this simple Ruby code. This calls the array reference method on Hash with a splat of a very large array with over a million entries.|It turns out that this bug is not specific to that Hash method. At the time the bug was reported, this issue applied to any method, when called with a splatted array, if the number of elements in the array was large enough.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 100px;"><code>Hash[*1380888.times.map{ 1 }]
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/7">

<div class="notes">You could reproduce the bug when calling the Kernel puts method.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 100px;"><code>puts(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/8">

<div class="notes">You could reproduce the bug when calling a method defined in Ruby.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 100px;"><code>def a(*ary)
end

a(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/9">

<div class="notes">You could even reproduce the bug with a method that does not accept any arguments, such as the Kernel object_id method. This is because the error occurs while setting up the arguments for the method call, before actually calling the method.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 348px; margin-left: 100px;"><code>object_id(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/10">

<div class="notes">Ruby’s behavior when passing a large array splat to a method has changed over time.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 250px; left: 635px;">Historical</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 430px; left: 624px;">Behavior</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/11">

<div class="notes">Back in Ruby 1.8, passing too many arguments to a method would result in the Ruby interpreter crashing and dumping core, both for methods defined in C and for methods defined in Ruby.</div>
<pre class="red" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>$ ruby18 -ve 'object_id(*1380888.times)'
ruby 1.8.7 (2013-06-27 patchlevel 374) [x86_64-openbsd]
Illegal instruction (core dumped)

$ ruby18 -e 'def a(*a) end; a(*1380888.times); p 1'
Illegal instruction (core dumped)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/12">

<div class="notes">In Ruby 1.9, this condition was recognized, and a SystemStackError was raised instead for both cases. Ruby 2.0 and 2.1 kept the same behavior as Ruby 1.9.</div>
<pre class="red" style="font-size: 48px; margin-top: 248px; margin-left: 20px;"><code>$ ruby19 -ve 'object_id(*1380888.times)'
ruby 1.9.3p551 (2014-11-13 revision 48407) [x86_64-openbsd]
-e:1: stack level too deep (SystemStackError)

$ ruby19 -e 'def a(*a) end; a(*1380888.times); p 1'
-e:1: stack level too deep (SystemStackError)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/13">

<div class="notes">In Ruby 2.2, Koichi Sasada, the author of the Ruby virtual machine, fixed the issue for methods defined in Ruby.</div>
<pre style="font-size: 48px; margin-top: 248px; margin-left: 20px;"><code><span class="red">$ ruby22 -ve 'object_id(*1380888.times)'
ruby 2.2.10p489 (2018-03-28 revision 63023) [x86_64-openbsd]
-e:1: stack level too deep (SystemStackError)</span>

$ ruby22 -e 'def a(*a) end; a(*1380888.times); p 1'
1
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/14">

<div class="notes">This same behavior remains in Ruby 3.2.</div>
<pre style="font-size: 48px; margin-top: 248px; margin-left: 20px;"><code><span class="red">$ ruby32 -ve 'object_id(*1380888.times)'
ruby 3.2.1 (2023-02-08 revision 31819e82c8) [x86_64-openbsd]
-e:1: stack level too deep (SystemStackError)</span>

$ ruby32 -e 'def a(*a) end; a(*1380888.times); p 1'
1
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/15">

<div class="notes">As you probably can guess, we fixed this issue in Ruby 3.3. So now calling the object_id method with a large array splat correctly results in an ArgumentError.</div>
<pre style="font-size: 32px; margin-top: 248px; margin-left: 20px;"><code>$ ruby33 -ve 'object_id(*1380888.times)'
ruby 3.3.0dev (2023-02-09T20:02:26Z master d620855101) [x86_64-openbsd]
-e:1:in `object_id': wrong number of arguments (given 1380888, expected 0) (ArgumentError)

object_id(*1380888.times)
          ^^^^^^^^^^^^^^
        from -e:1:in `&lt;main&gt;'

$ ruby33 -e 'def a(*a) end; a(*1380888.times); p 1'
1
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/16">

<div class="notes">If you switch to the example code given in the initial bug report, you can see that it works correctly, and returns a hash with a single entry.</div>
<pre style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>$ ruby33 -e 'p Hash[*1380888.times.map{ 1 }]'
{1=&gt;1}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/17">

<div class="notes">Some of you may be thinking, who cares about this issue? Surely nobody is splatting such a large array, right?</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 170px; left: 434px;">Who</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 300px; left: 324px;">Cares<span class="red">?</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/18">

<div class="notes">But do any of you have any code in your applications that does something like this, where you splat a variable when calling a method? I’m assuming most of us do.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>
some_method(*list)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/19">

<div class="notes">Any chance that you have code somewhere in one of the applications you maintain, that accepts user input and assigns it to a variable? Again, most of us probably have code like this.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/20">

<div class="notes">Any chance that the variable with user input is later splatted? This becomes less likely, but I’m guessing a small percentage of the audience has code somewhere that splats user input.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
some_method(*list)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/21">

<div class="notes">If so, you need to recognize that this probably allows a user to remotely trigger a SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
some_method(*list) # SystemStackError
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/22">

<div class="notes">Let’s say you know your application deals with user input, and you want to handle unexpected errors using rescue.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
<b class="block">begin
  some_method(*list) # SystemStackError
rescue
  cleanup_method
end</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/23">

<div class="notes">Unfortunately, this doesn’t work as you expect. If the call to some_method raises a SystemStackError, then cleanup_method will not be called.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError
rescue
  <b>cleanup_method</b>
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/24">

<div class="notes">That’s because this rescue does not catch SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError
<b>rescue</b>
  cleanup_method
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/25">

<div class="notes">rescue without an argument is the same as rescue StandardError.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError
rescue # <b>rescue StandardError</b>
  cleanup_method
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/26">

<div class="notes">And SystemStackError is a subclass of Exception, not a subclass of StandardError.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError<b> &lt; Exception</b>
rescue # rescue StandardError
  cleanup_method
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/27">

<div class="notes">Let’s say you expect some_method to raise non-StandardError exceptions, and you want to do some cleanup using a couple of methods, and then reraise the exception, using this code. What is the problem here?</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError
<b class="block">rescue Exception
  cleanup_method(*list)
  other_cleanup_method
  raise</b>
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/28">

<div class="notes">The problem is this call to cleanup method also raises a SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError
rescue Exception
  <b>cleanup_method(*list) # SystemStackError</b>
  other_cleanup_method
  raise
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/29">

<div class="notes">Which means that the call to other cleanup method will never be reached. Hopefully these examples were helpful in demonstrating that this issue may exist in your own code and may be triggerable remotely.</div>
<pre class="sh_ruby" style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>list = params['list']
begin
  some_method(*list) # SystemStackError
rescue Exception
  cleanup_method(*list) # SystemStackError
  <b>other_cleanup_method</b>
  raise
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/30">

<div class="notes">I am now going to discuss details about why this bug occurred. I will focus on how arguments were handled for methods defined in C in Ruby 3.2, which will generally apply to earlier Ruby versions as well.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 260px; left: 624px;">Why<span class="red">?</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/31">

<div class="notes">For background, I will first discuss how methods are defined using Ruby’s C-API.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 80px; left: 624px;">C<span class="blue">-</span>API</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 260px; left: 624px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 440px; left: 624px;">Definition</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/32">

<div class="notes">Here’s a example of how Kernel#itself is defined in Ruby.</div>
<pre class="sh_c" style="font-size: 54px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
rb_obj_itself(VALUE obj)
{
    return obj;
}

// ...

rb_define_method(rb_mKernel, "itself", rb_obj_itself, 0);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/33">

<div class="notes">This part is the C function for the method.</div>
<pre class="sh_c" style="font-size: 54px; margin-top: 48px; margin-left: 20px;"><code><b class="block">static VALUE
rb_obj_itself(VALUE obj)
{
    return obj;
}</b>

// ...

rb_define_method(rb_mKernel, "itself", rb_obj_itself, 0);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/34">

<div class="notes">This part is how the C function is registered as a method in Ruby.</div>
<pre class="sh_c" style="font-size: 54px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
rb_obj_itself(VALUE obj)
{
    return obj;
}

// ...

<b>rb_define_method(rb_mKernel, "itself", rb_obj_itself, 0);</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/35">

<div class="notes">Kernel#itself does not take any arguments, so you pass 0 as the number of arguments when registering the method.</div>
<pre class="sh_c" style="font-size: 54px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
rb_obj_itself(VALUE obj)
{
    return obj;
}

// ...

rb_define_method(rb_mKernel, "itself", rb_obj_itself, <b>0</b>);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/36">

<div class="notes">Since the Ruby method does not accept any arguments, the C function is called with a single argument, which is the receiver of the method.</div>
<pre class="sh_c" style="font-size: 54px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
rb_obj_itself(<b>VALUE obj</b>)
{
    return obj;
}

// ...

rb_define_method(rb_mKernel, "itself", rb_obj_itself, 0);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/37">

<div class="notes">VALUE here is the C type used for all Ruby objects. Both the C function argument and the C function return value must be Ruby objects.</div>
<pre class="sh_c" style="font-size: 54px; margin-top: 48px; margin-left: 20px;"><code>static <b>VALUE</b>
rb_obj_itself(<b>VALUE</b> obj)
{
    return obj;
}

// ...

rb_define_method(rb_mKernel, "itself", rb_obj_itself, 0);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/38">

<div class="notes">To start work on fixing this bug, I needed to find where the bug is occurring.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 260px; left: 624px;">Finding</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 420px; left: 1144px;">Bugs</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/39">

<div class="notes">One of the tools I use most when starting out debugging is grep, or git grep.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 260px; left: 624px;">grep</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/40">

<div class="notes">Another of the tools I use frequently when debugging C code is gdb, the GNU debugger.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 460px; left: 624px;">gdb</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/41">

<div class="notes">To get a general idea of how method calling works, we can ruby through gdb, and tell Ruby to execute the itself method,</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) 
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/42">

<div class="notes">then set a breakpoint on the underlying C function that will be called.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) break rb_obj_itself
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/43">

<div class="notes">If you are building Ruby with support for the shared library, most of Ruby is contained in a libruby shared object and not in the ruby binary itself, so you have to tell gdb that you want the breakpoint to be pending the shared library load.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) break rb_obj_itself
Function "rb_obj_itself" not defined.
Make breakpoint pending on future shared library load? (y or [n]) 
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/44">

<div class="notes">Then gdb will set the pending breakpoint.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) break rb_obj_itself
Function "rb_obj_itself" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (rb_obj_itself) pending.
(gdb) 
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/45">

<div class="notes">You can then tell gdb to run the ruby program.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) break rb_obj_itself
Function "rb_obj_itself" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (rb_obj_itself) pending.
(gdb) r
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/46">

<div class="notes">gdb runs ruby until it hits the breakpoint.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) break rb_obj_itself
Function "rb_obj_itself" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (rb_obj_itself) pending.
(gdb) r
Starting program: /path/to/ruby -e itself
[New thread 382119]

Thread 1 hit Breakpoint 1, rb_obj_itself at object.c:562
562     {
(gdb) 
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/47">

<div class="notes">At that point, you can use the gdb backtrace command to see how you ended up calling the rb_obj_itself function. This should show how Ruby calls methods defined in C.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e itself
(gdb) break rb_obj_itself
Function "rb_obj_itself" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (rb_obj_itself) pending.
(gdb) r
Starting program: /path/to/ruby -e itself
[New thread 382119]

Thread 1 hit Breakpoint 1, rb_obj_itself at object.c:562
562     {
(gdb) backtrace
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/48">

<div class="notes">Here is the simplified backtrace output. We can split this backtrace into 4 basic sections.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/49">

<div class="notes">The bottom section is basically everything Ruby runs before calling the itself method.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
<b class="block">#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/50">

<div class="notes">This section is generic method calling code, regardless of how the method was defined.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
<b class="block">#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080</b>
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/51">

<div class="notes">This section is code specific to calling methods defined in C.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
<b class="block">#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289</b>
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/52">

<div class="notes">At the very top, we have code specific to the itself method.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
<b>#0  rb_obj_itself at object.c:564</b>
#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/53">

<div class="notes">Since this bug occurs when calling methods defined in C, it seems likely that the problem is in one of these three functions, or one of the functions they call.|While this is helpful, it would be best if we could see exactly where the SystemStackError is being raised.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
<b class="block">#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289</b>
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/54">

<div class="notes">We can start by grepping to see where SystemStackError is defined.</div>
<pre style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>$ git grep \"SystemStackError\"
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/55">

<div class="notes">It is always nice when we get only a single result back.</div>
<pre style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>$ git grep \"SystemStackError\"
proc.c:    rb_eSysStackError = rb_define_class("SystemStackError", rb_eException);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/56">

<div class="notes">From this line, we can see that the SystemStackError Ruby class</div>
<pre style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>$ git grep \"SystemStackError\"
proc.c:    rb_eSysStackError = rb_define_class("<b>SystemStackError</b>", rb_eException);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/57">

<div class="notes">is stored in a C global variable named rb_eSysStackError.</div>
<pre style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>$ git grep \"SystemStackError\"
proc.c:    <b>rb_eSysStackError</b> = rb_define_class("SystemStackError", rb_eException);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/58">

<div class="notes">If we grep for that,</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep rb_eSysStackError
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/59">

<div class="notes">we get a few results, but for simplicity I will filter most of them out.</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep rb_eSysStackError
proc.c:    rb_vm_register_special_exception(ruby_error_sysstack, rb_eSysStackError, "stack level too deep");
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/60">

<div class="notes">The stack level too deep string gives a pretty good indication that we are on the right track.</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep rb_eSysStackError
proc.c:    rb_vm_register_special_exception(ruby_error_sysstack, rb_eSysStackError, <b>"stack level too deep"</b>);
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/61">

<div class="notes">Here we see a call to rb_vm_register_special_exception. I do not know what this function does, but based on the name, it probably registers an exception.</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep rb_eSysStackError
proc.c:    <b>rb_vm_register_special_exception</b>(ruby_error_sysstack, rb_eSysStackError, "stack level too deep");
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/62">

<div class="notes">Since we know that rb_eSysStackError is a reference to SystemStackError</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep rb_eSysStackError
proc.c:    rb_vm_register_special_exception(ruby_error_sysstack, <b>rb_eSysStackError</b>, "stack level too deep");
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/63">

<div class="notes">We can probably assume that the first argument is being registered with it.</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep rb_eSysStackError
proc.c:    rb_vm_register_special_exception(<b>ruby_error_sysstack</b>, rb_eSysStackError, "stack level too deep");
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/64">

<div class="notes">If we grep for ruby_error_systack,</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep ruby_error_sysstack
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/65">

<div class="notes">we get only four results.</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep ruby_error_sysstack
proc.c:    rb_vm_register_special_exception(ruby_error_sysstack, rb_eSysStackError, "stack level too deep");
vm_core.h:    ruby_error_sysstack,
vm_core.h:#define sysstack_error GET_VM()-&gt;special_exceptions[ruby_error_sysstack]
vm_insnhelper.c:    VALUE mesg = rb_ec_vm_ptr(ec)-&gt;special_exceptions[ruby_error_sysstack];
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/66">

<div class="notes">One of which we can ignore as it is the same line as the previous grep.</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep ruby_error_sysstack
<b>proc.c:    rb_vm_register_special_exception(ruby_error_sysstack, rb_eSysStackError, "stack level too deep");</b>
vm_core.h:    ruby_error_sysstack,
vm_core.h:#define sysstack_error GET_VM()-&gt;special_exceptions[ruby_error_sysstack]
vm_insnhelper.c:    VALUE mesg = rb_ec_vm_ptr(ec)-&gt;special_exceptions[ruby_error_sysstack];
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/67">

<div class="notes">This line seems interesting. What if we open up the related file and go to that line?</div>
<pre style="font-size: 28px; margin-top: 48px; margin-left: 20px;"><code>$ git grep ruby_error_sysstack
proc.c:    rb_vm_register_special_exception(ruby_error_sysstack, rb_eSysStackError, "stack level too deep");
vm_core.h:    ruby_error_sysstack,
vm_core.h:#define sysstack_error GET_VM()-&gt;special_exceptions[ruby_error_sysstack]
<b>vm_insnhelper.c:    VALUE mesg = rb_ec_vm_ptr(ec)-&gt;special_exceptions[ruby_error_sysstack];</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/68">

<div class="notes">Here’s the code around that line. There is one large indication that this is what we are looking for.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>NORETURN(static void ec_stack_overflow(rb_execution_context_t *ec, int));
static void
ec_stack_overflow(rb_execution_context_t *ec, int setup)
{
    <b>VALUE mesg = rb_ec_vm_ptr(ec)-&gt;special_exceptions[ruby_error_sysstack];</b>
    ec-&gt;raised_flag = RAISED_STACKOVERFLOW;
    if (setup) {
        VALUE at = rb_ec_backtrace_object(ec);
        mesg = ruby_vm_special_exception_copy(mesg);
        rb_ivar_set(mesg, idBt, at);
        rb_ivar_set(mesg, idBt_locations, at);
    }
    ec-&gt;errinfo = mesg;
    EC_JUMP_TAG(ec, TAG_RAISE);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/69">

<div class="notes">And that is the function name, which contains the words stack overflow. It looks like this is the function called if the stack would overflow, to raise an exception instead of crashing.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>NORETURN(static void ec_stack_overflow(rb_execution_context_t *ec, int));
static void
<b>ec_stack_overflow</b>(rb_execution_context_t *ec, int setup)
{
    VALUE mesg = rb_ec_vm_ptr(ec)-&gt;special_exceptions[ruby_error_sysstack];
    ec-&gt;raised_flag = RAISED_STACKOVERFLOW;
    if (setup) {
        VALUE at = rb_ec_backtrace_object(ec);
        mesg = ruby_vm_special_exception_copy(mesg);
        rb_ivar_set(mesg, idBt, at);
        rb_ivar_set(mesg, idBt_locations, at);
    }
    ec-&gt;errinfo = mesg;
    EC_JUMP_TAG(ec, TAG_RAISE);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/70">

<div class="notes">We can use gdb to see if that is correct. In this case, we will pass code that should trigger the stack overflow.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e 'itself(*1380888.times)'
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/71">

<div class="notes">Then set a breakpoint on the ec_stack_overflow function and then run the program.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e 'itself(*1380888.times)'
(gdb) break ec_stack_overflow
(gdb) r
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/72">

<div class="notes">Thankfully, we guessed correctly, and the breakpoint is hit.</div>
<pre style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>$ gdb --args ruby -e 'itself(*1380888.times)'
(gdb) break ec_stack_overflow
(gdb) r
[New thread 527494]

Thread 1 hit Breakpoint 2, ec_stack_overflow at ./vm_insnhelper.c:61
61          VALUE mesg = rb_ec_vm_ptr(ec)-&gt;special_exceptions[ruby_error_sysstack];
(gdb)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/73">

<div class="notes">We can use the backtrace command to see how we got there.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  ec_stack_overflow at ./vm_insnhelper.c:61
#1  vm_stackoverflow at ./vm_insnhelper.c:81
#2  vm_caller_setup_arg_splat at ./vm_args.c:795
#3  CALLER_SETUP_ARG at ./vm_insnhelper.c:2545
#4  vm_call_cfunc at ./vm_insnhelper.c:3286
#5  vm_call_method_each_type at ./vm_insnhelper.c:3920
#6  vm_call_method at ./vm_insnhelper.c:4044
#7  vm_call_general at ./vm_insnhelper.c:4088
#8  vm_sendish at ./vm_insnhelper.c:5080
#9  vm_exec_core at insns.def:820
#10 rb_vm_exec at vm.c:2374
#11 rb_iseq_eval_main at vm.c:2633
#12 rb_ec_exec_node at eval.c:289
#13 ruby_run_node at eval.c:330
#14 rb_main at ./main.c:38
#15 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/74">

<div class="notes">Most of the backtrace is the same as the previous one. I have highlighted the new lines.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
<b class="block">#0  ec_stack_overflow at ./vm_insnhelper.c:61
#1  vm_stackoverflow at ./vm_insnhelper.c:81
#2  vm_caller_setup_arg_splat at ./vm_args.c:795
#3  CALLER_SETUP_ARG at ./vm_insnhelper.c:2545
#4  vm_call_cfunc at ./vm_insnhelper.c:3286</b>
#5  vm_call_method_each_type at ./vm_insnhelper.c:3920
#6  vm_call_method at ./vm_insnhelper.c:4044
#7  vm_call_general at ./vm_insnhelper.c:4088
#8  vm_sendish at ./vm_insnhelper.c:5080
#9  vm_exec_core at insns.def:820
#10 rb_vm_exec at vm.c:2374
#11 rb_iseq_eval_main at vm.c:2633
#12 rb_ec_exec_node at eval.c:289
#13 ruby_run_node at eval.c:330
#14 rb_main at ./main.c:38
#15 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/75">

<div class="notes">The top two lines are both for functions with stack overflow in the name, so these are likely called when a potential stack overflow has been detected, and not the cause of the stack overflow.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
<b class="block">#0  ec_stack_overflow at ./vm_insnhelper.c:61
#1  vm_stackoverflow at ./vm_insnhelper.c:81</b>
#2  vm_caller_setup_arg_splat at ./vm_args.c:795
#3  CALLER_SETUP_ARG at ./vm_insnhelper.c:2545
#4  vm_call_cfunc at ./vm_insnhelper.c:3286
#5  vm_call_method_each_type at ./vm_insnhelper.c:3920
#6  vm_call_method at ./vm_insnhelper.c:4044
#7  vm_call_general at ./vm_insnhelper.c:4088
#8  vm_sendish at ./vm_insnhelper.c:5080
#9  vm_exec_core at insns.def:820
#10 rb_vm_exec at vm.c:2374
#11 rb_iseq_eval_main at vm.c:2633
#12 rb_ec_exec_node at eval.c:289
#13 ruby_run_node at eval.c:330
#14 rb_main at ./main.c:38
#15 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/76">

<div class="notes">The function directly before those lines, named vm_caller_setup_arg_splat, is the probable cause.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  ec_stack_overflow at ./vm_insnhelper.c:61
#1  vm_stackoverflow at ./vm_insnhelper.c:81
<b>#2  vm_caller_setup_arg_splat at ./vm_args.c:795</b>
#3  CALLER_SETUP_ARG at ./vm_insnhelper.c:2545
#4  vm_call_cfunc at ./vm_insnhelper.c:3286
#5  vm_call_method_each_type at ./vm_insnhelper.c:3920
#6  vm_call_method at ./vm_insnhelper.c:4044
#7  vm_call_general at ./vm_insnhelper.c:4088
#8  vm_sendish at ./vm_insnhelper.c:5080
#9  vm_exec_core at insns.def:820
#10 rb_vm_exec at vm.c:2374
#11 rb_iseq_eval_main at vm.c:2633
#12 rb_ec_exec_node at eval.c:289
#13 ruby_run_node at eval.c:330
#14 rb_main at ./main.c:38
#15 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/77">

<div class="notes">Here is the definition of that function.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/78">

<div class="notes">It determines which object is being splatted.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    <b>VALUE ary = argv[argc-1];</b>

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/79">

<div class="notes">If the object being splatted is not nil, we assume it is an array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!<b>NIL_P(ary)</b>) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/80">

<div class="notes">We then determine of the length of the array to splat.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        <b>long len = RARRAY_LEN(ary)</b>, i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/81">

<div class="notes">In the normal case, we copy all objects from the array to the VM stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

<b class="block">        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }</b>
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/82">

<div class="notes">Some of you are probably wondering, what is the VM stack?</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 260px; left: 24px;">VM</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 440px; left: 24px;">Stack<span class="blue">?</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/83">

<div class="notes">VM stack here refers to the stack used by Ruby’s virtual machine. Virtual machines are generally either stack-based or register-based, and Ruby’s virtual machine is stack-based. Ruby’s compiler compiles your Ruby code into virtual machine instructions, which operate on this stack. Values on the VM stack are Ruby objects.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 260px; left: 24px;">Virtual Machine</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 440px; left: 24px;">Stack</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/84">

<div class="notes">To understand the underlying SystemStackError issue, at this point, I think it would be helpful for me to explain how things are laid out in memory. This explanation will be oversimplified, brief, and at least partly wrong, but hopefully it will still help.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 160px; left: 574px;">Memory</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 320px; left: 624px;">Layout</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/85">

<div class="notes">You can consider memory as continuous storage from the lowest memory address, represented here by all zeroes, to the highest memory address, represented here by all Fs.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;">Memory</div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/86">

<div class="notes">Ruby is written in C, and while C does not use a virtual machine, C uses a stack to store stack frames. There is generally one stack frame per C function call, and the stack frame holds the memory locations of the local variables for that function.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/87">

<div class="notes">When C needs to store data in memory that is not stored on the stack, it first needs to allocate the memory from the operating system, often done using the malloc function. The section of memory where these allocations are located is referred to as the heap. Ruby uses malloc and other functions to allocate most of the memory it uses, so most of Ruby’s memory usage is on the C Heap.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center;">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/88">

<div class="notes">One of the things Ruby stores on the C heap is its object pool. This is where Ruby objects are stored in memory. For large objects, sometimes they do not fit in the space allocated, and excess data is stored elsewhere on the C heap.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center; ">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 440px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">Object Pool</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 410px; left: 950px;">0x18000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 510px; left: 950px;">0x1FFFFFFF</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/89">

<div class="notes">Another of the things Ruby stores here is the stack for Ruby’s virtual machine, which is what this presentation refers to as the VM stack. This is where Ruby stores stack frames for Ruby method calls, and where it temporarily stores references to objects that are passed as arguments to those methods.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center;">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 440px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">Object Pool</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 410px; left: 950px;">0x18000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 510px; left: 950px;">0x1FFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 590px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">VM Stack</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 560px; left: 950px;">0x30000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 660px; left: 950px;">0x30FFFFFF</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/90">

<div class="notes">If you try to pass too many arguments to a method call, or you have unbounded recursion, your program would try to write beyond the end of Ruby’s VM stack. Since Ruby 1.9, Ruby recognizes when you are about to do this, and raises a SystemStackError instead of having the program crash, as I discussed earlier.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center;">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 440px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">Object Pool</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 410px; left: 950px;">0x18000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 510px; left: 950px;">0x1FFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 590px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">VM Stack</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 560px; left: 950px;">0x30000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 660px; left: 950px;"><b class="outline">0x30FFFFFF</b></h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/91">

<div class="notes">While in this presentation, I discuss the VM stack as if it were a single place in memory, Ruby can have multiple VM stacks. The main thread has the main VM stack,</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center;">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 440px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">Object Pool</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 410px; left: 950px;">0x18000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 510px; left: 950px;">0x1FFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 590px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">VM Stack</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 560px; left: 950px;">0x30000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 660px; left: 950px;">0x30FFFFFF</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/92">

<div class="notes">but each additional thread has its own thread stack. VM stacks for additional threads are generally smaller than for the main thread.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center;">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 440px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">Object Pool</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 410px; left: 950px;">0x18000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 510px; left: 950px;">0x1FFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 590px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">VM Stack</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 560px; left: 950px;">0x30000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 660px; left: 950px;">0x30FFFFFF</h1>
<div class="red-background" style="position: absolute; top: 700px; left: 330px; width: 560px; height: 40px; line-height: 40px; font-size: 36px; text-align: center; vertical-align: middle;">VM Thread Stack</div>
<div class="red-background" style="position: absolute; top: 750px; left: 330px; width: 560px; height: 40px; line-height: 40px; font-size: 36px; text-align: center; vertical-align: middle;">VM Thread Stack</div>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/93">

<div class="notes">Additionally, each fiber you create also has its own fiber stack. Fiber stacks are generally smaller than thread stacks. One reason that Ruby doesn’t scale well for huge number of fibers is the garbage collection time for scanning fiber stacks.|In this presentation, the term VM stack refers to the stack used by the currently executing Ruby code, which could be the main thread stack, and or one of the separate thread or fiber stacks.</div>
<div class="red-background" style="position: absolute; top: 90px; left: 310px; width: 600px; height: 900px; line-height: 900px; font-size: 80px; text-align: center; vertical-align: middle;"></div>
<h1 class="red" style="font-size: 100px; position: absolute; top: 20px; left: 950px;">0x00000000</h1>
<h1 class="red" style="font-size: 100px; position: absolute; bottom: 60px; left: 950px;">0xFFFFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 140px; left: 320px; width: 580px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">C Stack</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 110px; left: 950px;">0x01000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 210px; left: 950px;">0x01FFFFFF</h1>
<div class="blue-background" style="position: absolute; top: 340px; left: 320px; width: 580px; height: 550px; font-size: 80px; text-align: center;">C Heap</div>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 310px; left: 950px;">0x10000000</h1>
<h1 class="blue" style="font-size: 50px; position: absolute; top: 860px; left: 950px;">0xEFFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 440px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">Object Pool</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 410px; left: 950px;">0x18000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 510px; left: 950px;">0x1FFFFFFF</h1>
<div class="red-background" style="position: absolute; top: 590px; left: 330px; width: 560px; height: 100px; line-height: 100px; font-size: 80px; text-align: center; vertical-align: middle;">VM Stack</div>
<h1 class="red" style="font-size: 50px; position: absolute; top: 560px; left: 950px;">0x30000000</h1>
<h1 class="red" style="font-size: 50px; position: absolute; top: 660px; left: 950px;">0x30FFFFFF</h1>
<div class="red-background" style="position: absolute; top: 700px; left: 330px; width: 560px; height: 40px; line-height: 40px; font-size: 36px; text-align: center; vertical-align: middle;">VM Thread Stack</div>
<div class="red-background" style="position: absolute; top: 750px; left: 330px; width: 560px; height: 40px; line-height: 40px; font-size: 36px; text-align: center; vertical-align: middle;">VM Thread Stack</div>
<div class="red-background" style="position: absolute; top: 800px; left: 330px; width: 560px; height: 30px; line-height: 30px; font-size: 28px; text-align: center; vertical-align: middle;">VM Fiber Stack</div>
<div class="red-background" style="position: absolute; top: 840px; left: 330px; width: 560px; height: 30px; line-height: 30px; font-size: 28px; text-align: center; vertical-align: middle;">VM Fiber Stack</div>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/94">

<div class="notes">If we go back to the inital example, we saw that we needed over a million arguments to trigger this issue. That’s because this uses the main VM stack.</div>
<pre style="font-size: 56px; margin-top: 248px; margin-left: 20px;"><code>$ ruby32 -e 'p Hash[*<b>1380888</b>.times.map{ 1 }]'
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/95">

<div class="notes">You only need about 132 thousand arguments to trigger this in a thread stack. One thing to be aware of is the majority of request handling in Ruby web applications is using thread stacks and not the main VM stack.|If your Ruby web application accepts JSON input, and will splat the result of the JSON input, triggering a SystemStackError remotely may be possible with less than 300 kilobytes uploaded.</div>
<pre style="font-size: 48px; margin-top: 248px; margin-left: 20px;"><code>$ ruby32 -e "Thread.new{Hash[*<b>132000</b>.times.map{ 1 }]}.join"
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/96">

<div class="notes">If you run your Ruby web application using a Fiber per request, it may take only 16400 arguments to trigger a SystemStackError.</div>
<pre style="font-size: 48px; margin-top: 248px; margin-left: 20px;"><code>$ ruby32 -e "Fiber.new{Hash[*<b>16400</b>.times.map{ 1 }]}.resume"
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/97">

<div class="notes">If you tune your Ruby application to decrease stack size per fiber or thread, for better garbage collection performance and reduced memory usage, triggering the SystemStackError may be possible with just over 2000 arguments.</div>
<pre style="font-size: 48px; margin-top: 248px; margin-left: 20px;"><code>$ set RUBY_FIBER_VM_STACK_SIZE=16384
$ ruby32 -e "Fiber.new{Hash[*<b>2010</b>.times.map{ 1 }]}.resume"
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/98">

<div class="notes">With that background, let’s get back to our example. To refresh, we just discussed this section, which copies all objects from the array to the VM stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

<b class="block">        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }</b>
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/99">

<div class="notes">After this, we increase the number of arguments the method is called with with the length of the splatted array, subtracting one for the array itself.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        <b>calling-&gt;argc += i - 1</b>;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/100">

<div class="notes">However, before doing any copying, we check whether copying all objects to the VM stack would overflow the stack, so that a SystemStackError can be raised instead of the program crashing. This is the check that is being hit when splatting a large array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        <b>CHECK_VM_STACK_OVERFLOW(cfp, len);</b>

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/101">

<div class="notes">Unfortunately, there is not a way to avoid this issue as long as you take the approach of copying all arguments from the splatted array to the VM stack. The only way to avoid the approach would be to not pass the arguments on the stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

<b class="block">        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }</b>
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/102">

<div class="notes">If we go back to the initial backtrace, when calling itself without any arguments.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/103">

<div class="notes">We see that the function calling rb_obj_itself is named ractor_safe_call_cfunc_0.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
#1  <b>ractor_safe_call_cfunc_0</b> at ./vm_insnhelper.c:3085
#2  vm_call_cfunc_with_frame at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/104">

<div class="notes">The prototype for that function looks like this.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>
ractor_safe_call_cfunc_0(VALUE recv, int argc, const VALUE *argv,
                         VALUE (*func)(ANYARGS))
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/105">

<div class="notes">It takes the receiver of the Ruby method,</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>
ractor_safe_call_cfunc_0(<b>VALUE recv</b>, int argc, const VALUE *argv,
                         VALUE (*func)(ANYARGS))
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/106">

<div class="notes">the number of arguments the Ruby method was called with,</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>
ractor_safe_call_cfunc_0(VALUE recv, <b>int argc</b>, const VALUE *argv,
                         VALUE (*func)(ANYARGS))
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/107">

<div class="notes">a pointer to the first argument for the method.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>
ractor_safe_call_cfunc_0(VALUE recv, int argc, <b>const VALUE *argv</b>,
                         VALUE (*func)(ANYARGS))
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/108">

<div class="notes">and a function pointer for the C function that implements the Ruby method.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>
ractor_safe_call_cfunc_0(VALUE recv, int argc, const VALUE *argv,
                         <b>VALUE (*func)(ANYARGS)</b>)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/109">

<div class="notes">Taking a step up, the function calling ractor_safe_call_cfunc_0 is named vm_call_cfunc_with_frame.</div>
<pre style="font-size: 42px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  rb_obj_itself at object.c:564
#1  ractor_safe_call_cfunc_0 at ./vm_insnhelper.c:3085
#2  <b>vm_call_cfunc_with_frame</b> at ./vm_insnhelper.c:3268
#3  vm_call_cfunc at ./vm_insnhelper.c:3289
#4  vm_call_method_each_type at ./vm_insnhelper.c:3920
#5  vm_call_method at ./vm_insnhelper.c:4044
#6  vm_call_general at ./vm_insnhelper.c:4088
#7  vm_sendish at ./vm_insnhelper.c:5080
#8  vm_exec_core at insns.def:820
#9  rb_vm_exec at vm.c:2374
#10 rb_iseq_eval_main at vm.c:2633
#11 rb_ec_exec_node at eval.c:289
#12 ruby_run_node at eval.c:330
#13 rb_main at ./main.c:38
#14 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/110">

<div class="notes">This function is large, so I will focus on the line calling ractor_safe_call_cfunc_0.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/111">

<div class="notes">It may be hard to tell that this is calling ractor_safe_call_cfunc_0, because that is actually stored in the invoker function pointer.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    val = <b>(*cfunc-&gt;invoker)</b>(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/112">

<div class="notes">The important part here is the value it is passing as the pointer to the first argument. In this case, it is always passing a pointer to the VM stack, and the stack is quite limited in size. Maybe if we could change this call to pass a pointer to somewhere else in memory, calling a method defined in C with a large array splat would work.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    val = (*cfunc-&gt;invoker)(recv, argc, <b>reg_cfp-&gt;sp + 1</b>, cfunc-&gt;func);
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/113">

<div class="notes">We can start that process back in the vm_caller_setup_arg_splat function.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static inline void
vm_caller_setup_arg_splat(rb_control_frame_t *cfp, struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];

    vm_check_canary(GET_EC(), cfp-&gt;sp);
    cfp-&gt;sp--;

    if (!NIL_P(ary)) {
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/114">

<div class="notes">Let’s reduce the code to focus on the case where there is an array to splat.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        CHECK_VM_STACK_OVERFLOW(cfp, len);

        for (i = 0; i &lt; len; i++) {
            *cfp-&gt;sp++ = ptr[i];
        }
        calling-&gt;argc += i - 1;
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/115">

<div class="notes">If some condition is true, we should use an approach that does not copy arguments to the VM stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

<b class="block">        if (some_condition) {
            // do not use stack
        }
        else {</b>
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        <b>}</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/116">

<div class="notes">One simple condition is if the number of arguments being passed to the method plus the length of the splatted array is over some high number, say 1000, then do not use the VM stack for argument passing.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (<b>argc + len &gt; 1000</b>) {
            // do not use stack
        }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/117">

<div class="notes">How should we pass the arguments if we are not going to pass them on the VM stack? One of the easiest ways to do so is to create a temporary Ruby array for the arguments, and then instead of passing a pointer to the stack, we can pass a pointer to the first element of that temporary array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            // <b>do not use stack</b>
        }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/118">

<div class="notes">Here is the code that implements that approach.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
<b class="block">            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;</b>
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/119">

<div class="notes">We start off by creating a Ruby array with the expected capacity.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            <b>VALUE argv_array = rb_ary_new_capa(len + argc - 1);</b>
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/120">

<div class="notes">We then hide the array. This makes sure the array cannot be accessed via ObjectSpace.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            <b>rb_obj_hide(argv_array);</b>
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/121">

<div class="notes">We copy the method arguments before the splatted array to the temporary array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            <b>rb_ary_cat(argv_array, argv, argc-1);</b>
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/122">

<div class="notes">Then we copy the elements of the splatted array to the temporary array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            <b>rb_ary_cat(argv_array, ptr, len);</b>
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/123">

<div class="notes">We still pass the pointer to the temporary array of arguments on the VM stack, so we need to adjust sp, the stack pointer, to reflect that.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
<b class="block">            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;</b>
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/124">

<div class="notes">Since there is only one argument on the VM stack, we adjust the calling information to show only one argument. This is correct from a stack perspective, but incorrect from a method calling perspective.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            <b>calling-&gt;argc = 1;</b>
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/125">

<div class="notes">Finally, we set a new flag in the calling information named heap_argv to flag that the arguments are being passed on the heap in a temporary array, instead of on the VM stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            <b>calling-&gt;heap_argv = 1;</b>
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/126">

<div class="notes">You may be wondering, how does this code that copies arguments before the splat and the splat itself handle arguments after the splat?</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
<b class="block">            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);</b>
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/127">

<div class="notes">It turns out, you do not need to worry about that, because Ruby’s compiler implicitly converts method calls with arguments after the splat like this,</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary, arg)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/128">

<div class="notes">into a single array that is then splatted. So the method argument handler does not need to worry about arguments after the splat.</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary, arg)
<b>a(*[*ary, arg])</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/129">

<div class="notes">What if you are splatting multiple arrays, as in this code?</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary1, *ary2)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/130">

<div class="notes">Similarly, Ruby combines both into a single array that is then splatted. So the method argument handler does not need to worry about multiple splats.</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary1, *ary2)
<b>a(*[*ary1, *ary2])</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/131">

<div class="notes">However, what about keyword arguments, either literal keyword arguments or a keyword argument splat?</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary, kw: 1)

a(*ary, **kw)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/132">

<div class="notes">This is actually a single case, since Ruby compiles a literal keyword argument after an argument splat</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
<b>a(*ary, kw: 1)</b>

a(*ary, **kw)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/133">

<div class="notes">as creating a new hash and then keyword splatting that hash.</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary, kw: 1)
<b>a(*ary, **{kw: 1})</b>
a(*ary, **kw)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/134">

<div class="notes">In Ruby 3.2, for all of these calls, the compiler will actually combine the argument splat and keywords into a single array, and set a special flag when calling.</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary, kw: 1)
a(*ary, **{kw: 1})
a(*ary, **kw)

<b>a(*[*ary, kw])</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/135">

<div class="notes">In Ruby 3.3, Koichi changed the compiler to not combine the keywords into the argument splat, avoiding 3 unnecessary array allocations and an unnecessary hash allocation.|That means the code in Ruby 3.3 does need to handle keyword argument splats to get correct behavior.</div>
<pre class="sh_ruby" style="font-size: 128px; margin-top: 48px; margin-left: 320px;"><code>
a(*ary, kw: 1)
a(*ary, **{kw: 1})
<b>a(*ary, **kw)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/136">

<div class="notes">To make sure the keyword splat is passed properly when using a temporary array to hold the arguments, after the call to vm_caller_setup_arg_splat, we push the keyword hash onto the array,</div>
<pre class="sh_c" style="font-size: 64px; margin-top: 48px; margin-left: 20px;"><code>
if (!RHASH_EMPTY_P(keyword_hash)) {
    <b>rb_ary_push(argv_array, keyword_hash);</b>
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/137">

<div class="notes">but only if the keyword hash is not empty, because empty keyword hashes are ignored.</div>
<pre class="sh_c" style="font-size: 64px; margin-top: 48px; margin-left: 20px;"><code>
if (<b>!RHASH_EMPTY_P(keyword_hash)</b>) {
    rb_ary_push(argv_array, keyword_hash);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/138">

<div class="notes">Back to the function for calling methods defined in C, now that we have setup the temporary array for arguments on the heap, we need to make changes to use the pointer to the first element of the array, instead of using a pointer to the VM stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/139">

<div class="notes">We need to recognize when to use the temporary array for arguments, which we can do by checking for the heap_argv flag.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
<b class="block">    if (calling-&gt;heap_argv) {
        // Use arguments from Ruby array
    }
    else {</b>
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    <b>}</b>
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/140">

<div class="notes">Here is the code for using the temporary array for arguments.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (calling-&gt;heap_argv) {
<b class="block">        VALUE argv_array = reg_cfp-&gt;sp[-1];
        VALUE argv = RARRAY_PTR(argv_array);
        argc = (int)RARRAY_LEN(argv_array);
        val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);</b>
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/141">

<div class="notes">We get the pointer to the temporary array containing the arguments.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (calling-&gt;heap_argv) {
        <b>VALUE argv_array = reg_cfp-&gt;sp[-1];</b>
        VALUE argv = RARRAY_PTR(argv_array);
        argc = (int)RARRAY_LEN(argv_array);
        val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/142">

<div class="notes">From that, we get the pointer to the first element of the temporary array. That pointer points to the heap, instead of the VM stack.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (calling-&gt;heap_argv) {
        VALUE argv_array = reg_cfp-&gt;sp[-1];
        <b>VALUE argv = RARRAY_PTR(argv_array);</b>
        argc = (int)RARRAY_LEN(argv_array);
        val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/143">

<div class="notes">We use the length of the temporary array as the number of method arguments.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (calling-&gt;heap_argv) {
        VALUE argv_array = reg_cfp-&gt;sp[-1];
        VALUE argv = RARRAY_PTR(argv_array);
        <b>argc = (int)RARRAY_LEN(argv_array);</b>
        val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/144">

<div class="notes">Finally, we call the C function using the correct number of arguments and pointer to the first element of the temporary array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (calling-&gt;heap_argv) {
        VALUE argv_array = reg_cfp-&gt;sp[-1];
        VALUE argv = RARRAY_PTR(argv_array);
        argc = (int)RARRAY_LEN(argv_array);
        <b>val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);</b>
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/145">

<div class="notes">While the changes that I went over are the most important changes, there were a few changes needed in other functions,</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (calling-&gt;heap_argv) {
        VALUE argv_array = reg_cfp-&gt;sp[-1];
        VALUE argv = RARRAY_PTR(argv_array);
        argc = (int)RARRAY_LEN(argv_array);
        val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/146">

<div class="notes">mostly to check if the heap argv flag was set, and handling things differently in that case. I do not have time to discuss the other places that needed to be changed, but it requiring adding about 5 different checks for the heap argv flag.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc_with_frame(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
                         struct rb_calling_info *calling)
{
    // ...
    if (<b>calling-&gt;heap_argv</b>) {
        VALUE argv_array = reg_cfp-&gt;sp[-1];
        VALUE argv = RARRAY_PTR(argv_array);
        argc = (int)RARRAY_LEN(argv_array);
        val = (*cfunc-&gt;invoker)(recv, argc, argv, cfunc-&gt;func);
    }
    else {
        val = (*cfunc-&gt;invoker)(recv, argc, reg_cfp-&gt;sp + 1, cfunc-&gt;func);
    }
    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/147">

<div class="notes">After making those changes, it did not take much more work to get Ruby’s test suite passing with this change.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 160px; left: 627px;">Passes</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 330px; left: 624px;">Tests<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/148">

<div class="notes">Unfortunately, while the tests passed, this change resulted in a minor slowdown. The additional checks slowed down method calling microbenchmarks by up to seven percent. Considering that few users are affected by this bug, slowing down method calling to such a degree was not acceptable.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 360px; left: 624px;">Minor</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 540px; left: 624px;">Slowdown<span class="red">!!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/149">

<div class="notes">I tried a couple different approaches to speed up the implementation. Ultimately, I was able to get the performance difference to be small enough that even the microbenchmark did not show it as slower.</div>
<h1 class="blue" style="font-size: 200px; position: absolute; top: 580px; left: 600px;">Speedup</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 720px; left: 624px;">Attempt</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/150">

<div class="notes">However, my approach was a little invasive, making multiple changes to a couple methods that were used in the generic method dispatch code. Since the issue had already been fixed for many years for methods defined in Ruby, and we were trying to fix it for methods defined in C, it would be nice if the changes could be made only to the dispatch code for methods defined in C.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 460px; right: 424px;">Invasive</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/151">

<div class="notes">In discussions with Koichi, I mentioned that we could switch to that approach, but it would result in more duplication. Koichi took it upon himself to implement that noninvasive approach.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 460px; right: 424px;">
<span class="blue">Non</span>invasive</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/152">

<div class="notes">It turns out I was right about the duplication. Here is the vm_call_cfunc function before the changes.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 28px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    const struct rb_callinfo *ci = calling-&gt;ci;
    RB_DEBUG_COUNTER_INC(ccf_cfunc);

    CALLER_SETUP_ARG(reg_cfp, calling, ci);
    CALLER_REMOVE_EMPTY_KW_SPLAT(reg_cfp, calling, ci);
    CC_SET_FASTPATH(calling-&gt;cc, vm_call_cfunc_with_frame,
                    !rb_splat_or_kwargs_p(ci) &amp;&amp; !calling-&gt;kw_splat);
    return vm_call_cfunc_with_frame(ec, reg_cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/153">

<div class="notes">To give the correct perspective, I will shrink the font size. Now let’s see the changes.</div>
<pre class="sh_c" style="font-size: 15px; margin-top: 28px; margin-left: 20px;"><code>static VALUE
vm_call_cfunc(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    const struct rb_callinfo *ci = calling-&gt;ci;
    RB_DEBUG_COUNTER_INC(ccf_cfunc);

    CALLER_SETUP_ARG(reg_cfp, calling, ci);
    CALLER_REMOVE_EMPTY_KW_SPLAT(reg_cfp, calling, ci);
    CC_SET_FASTPATH(calling-&gt;cc, vm_call_cfunc_with_frame,
                    !rb_splat_or_kwargs_p(ci) &amp;&amp; !calling-&gt;kw_splat);
    return vm_call_cfunc_with_frame(ec, reg_cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/154">

<div class="notes">As you can see, this is quite a large increase in lines.</div>
<pre class="sh_c" style="font-size: 15px; margin-top: 28px; margin-left: 20px; columns: 2;"><code>static VALUE
vm_call_cfunc_setup_argv_ary(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];
    long len = RARRAY_LEN(ary);

    if (UNLIKELY(len + argc &gt; VM_ARGC_STACK_MAX)) {
        vm_check_canary(ec, cfp-&gt;sp);
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        VALUE argv_ary = rb_ary_new_capa(len + argc - 1);
        rb_obj_hide(argv_ary);
        rb_ary_cat(argv_ary, argv, argc-1);
        rb_ary_cat(argv_ary, ptr, len);
        cfp-&gt;sp -= argc - 1;
        cfp-&gt;sp[-1] = argv_ary;
        calling-&gt;argc = 1;

        return argv_ary;
    }
    else {
        return Qfalse;
    }
}

static VALUE
vm_call_cfunc(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    const struct rb_callinfo *ci = calling-&gt;ci;
    RB_DEBUG_COUNTER_INC(ccf_cfunc);

    VALUE argv_ary;

    if (UNLIKELY(IS_ARGS_SPLAT(ci)) &amp;&amp; (argv_ary = vm_call_cfunc_setup_argv_ary(ec, reg_cfp, calling))) {
        // special case of CALLER_SETUP_ARG
        if (!IS_ARGS_KW_OR_KW_SPLAT(ci)) {
            long hash_idx = RARRAY_LEN(argv_ary) - 1;
            VALUE final_hash = RARRAY_AREF(argv_ary, hash_idx);

            if (RB_TYPE_P(final_hash, T_HASH) &amp;&amp;
                (((struct RHash *)final_hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS)) {
                if (RHASH_EMPTY_P(final_hash)) {
                    rb_ary_pop(argv_ary);
                }
                else {
                    final_hash = rb_hash_dup(final_hash);
                    RARRAY_ASET(argv_ary, hash_idx, final_hash);
                    calling-&gt;kw_splat = 1;
                }
            }
        }

        if (UNLIKELY(IS_ARGS_KW_OR_KW_SPLAT(ci))) {
            VM_ASSERT(!IS_ARGS_KEYWORD(ci)); // should be KW_SPLAT

            long hash_idx = RARRAY_LEN(argv_ary) - 1;
            VALUE keyword_hash = RARRAY_AREF(argv_ary, hash_idx);

            if (!RB_TYPE_P(keyword_hash, T_HASH)) {
                /* Convert a non-hash keyword splat to a new hash */
                RARRAY_ASET(argv_ary, hash_idx, rb_hash_dup(rb_to_hash_type(keyword_hash)));
            }
            else if (!IS_ARGS_KW_SPLAT_MUT(ci)) {
                /* Convert a hash keyword splat to a new hash unless
                 * a mutable keyword splat was passed.
                 */
                RARRAY_ASET(argv_ary, hash_idx, rb_hash_dup(keyword_hash));
            }
        }

        // special case of CALLER_REMOVE_EMPTY_KW_SPLAT()
        if (UNLIKELY(calling-&gt;kw_splat)) {
            VALUE kw_hash = RARRAY_AREF(argv_ary, RARRAY_LEN(argv_ary)-1);
            if (RHASH_EMPTY_P(kw_hash)) {
                rb_ary_pop(argv_ary);
                calling-&gt;kw_splat = false;
            }
        }

        int argc = RARRAY_LENINT(argv_ary);
        VALUE *argv = (void *)RARRAY_CONST_PTR_TRANSIENT(argv_ary);
        VALUE *stack_bottom = reg_cfp-&gt;sp - 2;

        VM_ASSERT(calling-&gt;argc == 1);
        VM_ASSERT(RB_TYPE_P(argv_ary, T_ARRAY));
        VM_ASSERT(RBASIC_CLASS(argv_ary) == 0); // hidden ary

        return vm_call_cfunc_with_frame_(ec, reg_cfp, calling, argc, argv, stack_bottom);
    }
    else {
        CALLER_SETUP_ARG(reg_cfp, calling, ci);
        CALLER_REMOVE_EMPTY_KW_SPLAT(reg_cfp, calling, ci);
        CC_SET_FASTPATH(calling-&gt;cc, vm_call_cfunc_with_frame,
                        !rb_splat_or_kwargs_p(ci) &amp;&amp; !calling-&gt;kw_splat);

        return vm_call_cfunc_with_frame(ec, reg_cfp, calling);
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/155">

<div class="notes">These two lines in the normal case, when you are not passing a large argument splat, use the standard argument setup functions.</div>
<pre class="sh_c" style="font-size: 15px; margin-top: 28px; margin-left: 20px; columns: 2;"><code>static VALUE
vm_call_cfunc_setup_argv_ary(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];
    long len = RARRAY_LEN(ary);

    if (UNLIKELY(len + argc &gt; VM_ARGC_STACK_MAX)) {
        vm_check_canary(ec, cfp-&gt;sp);
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        VALUE argv_ary = rb_ary_new_capa(len + argc - 1);
        rb_obj_hide(argv_ary);
        rb_ary_cat(argv_ary, argv, argc-1);
        rb_ary_cat(argv_ary, ptr, len);
        cfp-&gt;sp -= argc - 1;
        cfp-&gt;sp[-1] = argv_ary;
        calling-&gt;argc = 1;

        return argv_ary;
    }
    else {
        return Qfalse;
    }
}

static VALUE
vm_call_cfunc(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    const struct rb_callinfo *ci = calling-&gt;ci;
    RB_DEBUG_COUNTER_INC(ccf_cfunc);

    VALUE argv_ary;

    if (UNLIKELY(IS_ARGS_SPLAT(ci)) &amp;&amp; (argv_ary = vm_call_cfunc_setup_argv_ary(ec, reg_cfp, calling))) {
        // special case of CALLER_SETUP_ARG
        if (!IS_ARGS_KW_OR_KW_SPLAT(ci)) {
            long hash_idx = RARRAY_LEN(argv_ary) - 1;
            VALUE final_hash = RARRAY_AREF(argv_ary, hash_idx);

            if (RB_TYPE_P(final_hash, T_HASH) &amp;&amp;
                (((struct RHash *)final_hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS)) {
                if (RHASH_EMPTY_P(final_hash)) {
                    rb_ary_pop(argv_ary);
                }
                else {
                    final_hash = rb_hash_dup(final_hash);
                    RARRAY_ASET(argv_ary, hash_idx, final_hash);
                    calling-&gt;kw_splat = 1;

                }
            }
        }

        if (UNLIKELY(IS_ARGS_KW_OR_KW_SPLAT(ci))) {
            VM_ASSERT(!IS_ARGS_KEYWORD(ci)); // should be KW_SPLAT

            long hash_idx = RARRAY_LEN(argv_ary) - 1;
            VALUE keyword_hash = RARRAY_AREF(argv_ary, hash_idx);

            if (!RB_TYPE_P(keyword_hash, T_HASH)) {
                /* Convert a non-hash keyword splat to a new hash */
                RARRAY_ASET(argv_ary, hash_idx, rb_hash_dup(rb_to_hash_type(keyword_hash)));
            }
            else if (!IS_ARGS_KW_SPLAT_MUT(ci)) {
                /* Convert a hash keyword splat to a new hash unless
                 * a mutable keyword splat was passed.
                 */
                RARRAY_ASET(argv_ary, hash_idx, rb_hash_dup(keyword_hash));
            }
        }

        // special case of CALLER_REMOVE_EMPTY_KW_SPLAT()
        if (UNLIKELY(calling-&gt;kw_splat)) {
            VALUE kw_hash = RARRAY_AREF(argv_ary, RARRAY_LEN(argv_ary)-1);
            if (RHASH_EMPTY_P(kw_hash)) {
                rb_ary_pop(argv_ary);
                calling-&gt;kw_splat = false;
            }
        }

        int argc = RARRAY_LENINT(argv_ary);
        VALUE *argv = (void *)RARRAY_CONST_PTR_TRANSIENT(argv_ary);
        VALUE *stack_bottom = reg_cfp-&gt;sp - 2;

        VM_ASSERT(calling-&gt;argc == 1);
        VM_ASSERT(RB_TYPE_P(argv_ary, T_ARRAY));
        VM_ASSERT(RBASIC_CLASS(argv_ary) == 0); // hidden ary

        return vm_call_cfunc_with_frame_(ec, reg_cfp, calling, argc, argv, stack_bottom);
    }
    else {
<b class="block">        CALLER_SETUP_ARG(reg_cfp, calling, ci);
        CALLER_REMOVE_EMPTY_KW_SPLAT(reg_cfp, calling, ci);</b>
        CC_SET_FASTPATH(calling-&gt;cc, vm_call_cfunc_with_frame,
                        !rb_splat_or_kwargs_p(ci) &amp;&amp; !calling-&gt;kw_splat);

        return vm_call_cfunc_with_frame(ec, reg_cfp, calling);
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/156">

<div class="notes">Those two lines are replaced with expanded and customized versions in the case where you are splatting a large array.</div>
<pre class="sh_c" style="font-size: 15px; margin-top: 28px; margin-left: 20px; columns: 2;"><code><b class="block">static VALUE
vm_call_cfunc_setup_argv_ary(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    int argc = calling-&gt;argc;
    VALUE *argv = cfp-&gt;sp - argc;
    VALUE ary = argv[argc-1];
    long len = RARRAY_LEN(ary);

    if (UNLIKELY(len + argc &gt; VM_ARGC_STACK_MAX)) {
        vm_check_canary(ec, cfp-&gt;sp);
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        VALUE argv_ary = rb_ary_new_capa(len + argc - 1);
        rb_obj_hide(argv_ary);
        rb_ary_cat(argv_ary, argv, argc-1);
        rb_ary_cat(argv_ary, ptr, len);
        cfp-&gt;sp -= argc - 1;
        cfp-&gt;sp[-1] = argv_ary;
        calling-&gt;argc = 1;

        return argv_ary;
    }
    else {
        return Qfalse;
    }
}</b>

static VALUE
vm_call_cfunc(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,
              struct rb_calling_info *calling)
{
    const struct rb_callinfo *ci = calling-&gt;ci;
    RB_DEBUG_COUNTER_INC(ccf_cfunc);

    VALUE argv_ary;

    if (UNLIKELY(IS_ARGS_SPLAT(ci)) &amp;&amp; (argv_ary = vm_call_cfunc_setup_argv_ary(ec, reg_cfp, calling))) {
<b class="block">        // special case of CALLER_SETUP_ARG
        if (!IS_ARGS_KW_OR_KW_SPLAT(ci)) {
            long hash_idx = RARRAY_LEN(argv_ary) - 1;
            VALUE final_hash = RARRAY_AREF(argv_ary, hash_idx);

            if (RB_TYPE_P(final_hash, T_HASH) &amp;&amp;
                (((struct RHash *)final_hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS)) {
                if (RHASH_EMPTY_P(final_hash)) {
                    rb_ary_pop(argv_ary);
                }
                else {
                    final_hash = rb_hash_dup(final_hash);
                    RARRAY_ASET(argv_ary, hash_idx, final_hash);
                    calling-&gt;kw_splat = 1;</b>
<b class="block">                }
            }
        }

        if (UNLIKELY(IS_ARGS_KW_OR_KW_SPLAT(ci))) {
            VM_ASSERT(!IS_ARGS_KEYWORD(ci)); // should be KW_SPLAT

            long hash_idx = RARRAY_LEN(argv_ary) - 1;
            VALUE keyword_hash = RARRAY_AREF(argv_ary, hash_idx);

            if (!RB_TYPE_P(keyword_hash, T_HASH)) {
                /* Convert a non-hash keyword splat to a new hash */
                RARRAY_ASET(argv_ary, hash_idx, rb_hash_dup(rb_to_hash_type(keyword_hash)));
            }
            else if (!IS_ARGS_KW_SPLAT_MUT(ci)) {
                /* Convert a hash keyword splat to a new hash unless
                 * a mutable keyword splat was passed.
                 */
                RARRAY_ASET(argv_ary, hash_idx, rb_hash_dup(keyword_hash));
            }
        }

        // special case of CALLER_REMOVE_EMPTY_KW_SPLAT()
        if (UNLIKELY(calling-&gt;kw_splat)) {
            VALUE kw_hash = RARRAY_AREF(argv_ary, RARRAY_LEN(argv_ary)-1);
            if (RHASH_EMPTY_P(kw_hash)) {
                rb_ary_pop(argv_ary);
                calling-&gt;kw_splat = false;
            }
        }

        int argc = RARRAY_LENINT(argv_ary);
        VALUE *argv = (void *)RARRAY_CONST_PTR_TRANSIENT(argv_ary);
        VALUE *stack_bottom = reg_cfp-&gt;sp - 2;

        VM_ASSERT(calling-&gt;argc == 1);
        VM_ASSERT(RB_TYPE_P(argv_ary, T_ARRAY));
        VM_ASSERT(RBASIC_CLASS(argv_ary) == 0); // hidden ary</b>

        return vm_call_cfunc_with_frame_(ec, reg_cfp, calling, argc, argv, stack_bottom);
    }
    else {
        CALLER_SETUP_ARG(reg_cfp, calling, ci);
        CALLER_REMOVE_EMPTY_KW_SPLAT(reg_cfp, calling, ci);
        CC_SET_FASTPATH(calling-&gt;cc, vm_call_cfunc_with_frame,
                        !rb_splat_or_kwargs_p(ci) &amp;&amp; !calling-&gt;kw_splat);

        return vm_call_cfunc_with_frame(ec, reg_cfp, calling);
    }
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/157">

<div class="notes">There is a maintainability tradeoff here.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 232px; left: 350px;">Tradeoff</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/158">

<div class="notes">One option is to add features to generic functions, making the functions more complicated. This can make the generic functions slower, and can make it more difficult to debug code that does not benefit from the features. On the plus side, this can make maintenance easier, especially if future code can also benefit from the features added to the generic functions. My approach choose this tradeoff.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 432px; left: 350px;">Complicate</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/159">

<div class="notes">Another option is to duplicate the parts of the generic functions you need, and modify them for the specific use case. This can result in faster code, and it localizes the change. However, it can make maintenance more challenging if you need to make the same change in multiple places. Koichi’s approach chose this tradeoff.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 632px; left: 350px;">Duplicate</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/160">

<div class="notes">Koichi’s patch was merged in January, ensuring that the second oldest bug</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/161">

<div class="notes">will be fixed in Ruby 3.3.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 740px; left: 74px;">Fixed<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/162">

<div class="notes">At least, that is what I thought when I started working on this presentation. It turns out, this bug is not a single bug, but a general class of bugs, and my initial patch and Koichi’s committed patch only fixed a single instance of this class of bugs.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 740px; left: 74px;">Fixed<span class="red">?</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/163">

<div class="notes">So the bug was not fixed, or at least, not completely fixed. I will go over some code that still raised SystemStackError for large argument splats after the patch was committed.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 740px; left: 74px;"><span class="strike">Fixed</span></h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/164">

<div class="notes">I mentioned earlier that Koichi made changes in Ruby 2.2 to allow this code to work.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/165">

<div class="notes">However, if you replace the normal singleton method definition</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
<b class="block">def self.a(*ary)
  ary.length
end</b>

a(*1380888.times)
# =&gt; 1380888
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/166">

<div class="notes">with the equivalent define_singleton_method call</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
<b class="block">define_singleton_method(:a) do |*ary|
  ary.length
end</b>

a(*1380888.times)
# =&gt; 1380888
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/167">

<div class="notes">it raised a SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
define_singleton_method(:a) do |*ary|
  ary.length
end

a(*1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/168">

<div class="notes">To understand why the normal method definition approach worked but the block based approach failed, you need to understand that Ruby has multiple method types, each of which is handled differently internally.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 24px; left: 150px;">Method</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 212px; left: 220px;">Types</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/169">

<div class="notes">Ruby has a C function named vm_call_method_each_type, which handles all of the different method types that Ruby supports. A simplified version of this function is shown here.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/170">

<div class="notes">This function uses a C switch statement on the type of the method, similar to a Ruby case expression.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    <b>switch (cme-&gt;def-&gt;type)</b> {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/171">

<div class="notes">Normal ruby methods defined with def use the iseq method type.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case <b>VM_METHOD_TYPE_ISEQ</b>:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/172">

<div class="notes">Logic specific to calling iseq methods is in vm_call_iseq_setup. This is the code path that Koichi fixed in Ruby 2.2 to allow normal methods to accept large argument splats.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return <b>vm_call_iseq_setup(ec, cfp, calling)</b>;

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/173">

<div class="notes">Ruby methods defined by C functions use the cfunc method type.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case <b>VM_METHOD_TYPE_CFUNC</b>:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/174">

<div class="notes">Logic specific to calling cfunc methods is in vm_call_cfunc. This is the code path that was fixed by my initial patch and Koichi’s patch.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return <b>vm_call_cfunc(ec, cfp, calling)</b>;

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/175">

<div class="notes">Ruby methods defined with define_method or define_singleton_method use the bmethod type. I think bmethod is short for block method, since these are methods defined by blocks.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case <b>VM_METHOD_TYPE_BMETHOD</b>:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/176">

<div class="notes">Logic specific to calling bmethods is in vm_call_bmethod. This is one code path that had not been fixed, which is why calling a bmethod with a large argument splat raised SystemStackError even after Koichi’s patch was merged.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return <b>vm_call_bmethod(ec, cfp, calling)</b>;
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/177">

<div class="notes">Unrelated to the current bug, but useful to know, is that Ruby uses a call cache to improve performance. The first time you call a method, the call cache directs you to the slower generic method dispatch function.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    <b>const struct rb_callcache *cc = calling-&gt;cc;</b>
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/178">

<div class="notes">However, once Ruby figures out a more specific method handler, it updates the call cache, so that future method calls at the same callsite can jump directly to the specific method handler.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        <b>CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);</b>
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        <b>CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);</b>
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        <b>CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);</b>
        return vm_call_bmethod(ec, cfp, calling);
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/179">

<div class="notes">Going back to the vm_call_bmethod function, we need to determine why it fails.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_each_type(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                         struct rb_calling_info *calling)
{
    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);

    switch (cme-&gt;def-&gt;type) {
      case VM_METHOD_TYPE_ISEQ:
        CC_SET_FASTPATH(cc, vm_call_iseq_setup, TRUE);
        return vm_call_iseq_setup(ec, cfp, calling);

      case VM_METHOD_TYPE_CFUNC:
        CC_SET_FASTPATH(cc, vm_call_cfunc, TRUE);
        return vm_call_cfunc(ec, cfp, calling);

      case VM_METHOD_TYPE_BMETHOD:
        CC_SET_FASTPATH(cc, vm_call_bmethod, TRUE);
        return <b>vm_call_bmethod(ec, cfp, calling)</b>;
      // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/180">

<div class="notes">Here is the definition of the vm_call_bmethod function. There is one similarity here with the vm_call_cfunc function before we fixed the bug for cfunc methods.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci);
    argc = calling-&gt;argc;
    argv = ALLOCA_N(VALUE, argc);
    MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
    cfp-&gt;sp += - argc - 1;

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/181">

<div class="notes">That similarity is in the use of the CALLER_SETUP_ARG function.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    <b>CALLER_SETUP_ARG(cfp, calling, ci);</b>
    argc = calling-&gt;argc;
    argv = ALLOCA_N(VALUE, argc);
    MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
    cfp-&gt;sp += - argc - 1;

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/182">

<div class="notes">Looking back at the backtrace for the stack overflow for cfunc methods, we see that the stack overflow happens during a call to the CALLER_SETUP_ARG function. It turns out that all callers of this function are vulnerable to this issue. In Ruby 3.2, all method types other than iseq use CALLER_SETUP_ARG, which is why they were all vulnerable to this issue.</div>
<pre style="font-size: 40px; margin-top: 48px; margin-left: 20px;"><code>(gdb) backtrace
#0  ec_stack_overflow at ./vm_insnhelper.c:61
#1  vm_stackoverflow at ./vm_insnhelper.c:81
#2  vm_caller_setup_arg_splat at ./vm_args.c:795
#3  <b>CALLER_SETUP_ARG</b> at ./vm_insnhelper.c:2545
#4  vm_call_cfunc at ./vm_insnhelper.c:3286
#5  vm_call_method_each_type at ./vm_insnhelper.c:3920
#6  vm_call_method at ./vm_insnhelper.c:4044
#7  vm_call_general at ./vm_insnhelper.c:4088
#8  vm_sendish at ./vm_insnhelper.c:5080
#9  vm_exec_core at insns.def:820
#10 rb_vm_exec at vm.c:2374
#11 rb_iseq_eval_main at vm.c:2633
#12 rb_ec_exec_node at eval.c:289
#13 ruby_run_node at eval.c:330
#14 rb_main at ./main.c:38
#15 main at ./main.c:57
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/183">

<div class="notes">I mentioned earlier that my initial patch to fix this issue made the generic argument setup code more complicated,</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 432px; left: 350px;">Complicate</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/184">

<div class="notes">while Koichi’s patch was less invasive because it only modified the logic for cfunc methods. The duplication approach may be preferable when you only have a problem in a specific case. However, because all usage of CALLER_SETUP_ARG is vulnernable to this issue, the duplication approach is not maintainable.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 632px; left: 350px;">Duplicate</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/185">

<div class="notes">The only maintainable approach that fixes the issue for all cases requires complicating the generic code.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 432px; left: 350px;">Complicate</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/186">

<div class="notes">Here is the initial code I discussed earlier to avoid the SystemStackError. Between when I originally submitted my pull request and when I started working on this presentation and found the additional bugs, Koichi had modified the related code to significantly improve peformance.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
<b class="block">            VALUE argv_array = rb_ary_new_capa(len + argc - 1);
            rb_obj_hide(argv_array);
            rb_ary_cat(argv_array, argv, argc-1);
            rb_ary_cat(argv_array, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_array;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = 1;</b>
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/187">

<div class="notes">I had to make some changes to my original patch to adjust for Koichi’s changes. One of the changes is at the point this code is called, the array has already been removed from the VM stack. Another of the changes is that any keyword splat is passed as a separate argument and not as the last element of the array.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
<b class="block">            VALUE *argv = cfp-&gt;sp - argc;
            VALUE argv_ary = rb_ary_hidden_new(len + argc + 1);
            rb_ary_cat(argv_ary, argv, argc);
            rb_ary_cat(argv_ary, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_ary;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = argv_ary;</b>
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/188">

<div class="notes">Instead of separate rb_ary_new_capa and rb_obj_hide functions, I found there was an rb_ary_hidden_new function that combined the two features, so I switched to calling that.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE *argv = cfp-&gt;sp - argc;
            VALUE argv_ary = <b>rb_ary_hidden_new(len + argc + 1);</b>
            rb_ary_cat(argv_ary, argv, argc);
            rb_ary_cat(argv_ary, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_ary;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = argv_ary;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/189">

<div class="notes">The capacity of the temporary array is set to the number of arguments before the splat, plus the number of arguments in the array being splatted, with one extra for a possible keyword hash.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE *argv = cfp-&gt;sp - argc;
            VALUE argv_ary = rb_ary_hidden_new(<b>len + argc + 1</b>);
            rb_ary_cat(argv_ary, argv, argc);
            rb_ary_cat(argv_ary, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_ary;
            calling-&gt;argc = 1;
            calling-&gt;heap_argv = argv_ary;
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/190">

<div class="notes">The other important change is that I switched to storing a pointer to the temporary array in the calling structure, instead of only storing the pointer on the VM stack. This was mostly for simplicitly so I could easily reference it later.</div>
<pre class="sh_c" style="font-size: 36px; margin-top: 18px; margin-left: 20px;"><code>
        const VALUE *ptr = RARRAY_CONST_PTR_TRANSIENT(ary);
        long len = RARRAY_LEN(ary), i;

        if (argc + len &gt; 1000) {
            VALUE *argv = cfp-&gt;sp - argc;
            VALUE argv_ary = rb_ary_hidden_new(len + argc + 1);
            rb_ary_cat(argv_ary, argv, argc);
            rb_ary_cat(argv_ary, ptr, len);
            cfp-&gt;sp -= argc - 1;
            cfp-&gt;sp[-1] = argv_ary;
            calling-&gt;argc = 1;
            <b>calling-&gt;heap_argv = argv_ary;</b>
       }
        else {
            CHECK_VM_STACK_OVERFLOW(cfp, len);

            for (i = 0; i &lt; len; i++) {
                *cfp-&gt;sp++ = ptr[i];
            }
            calling-&gt;argc += i - 1;
        }
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/191">

<div class="notes">If we go back to the vm_call_bmethod function, we can modify it to use this new approach.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci);
    argc = calling-&gt;argc;
    argv = ALLOCA_N(VALUE, argc);
    MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
    cfp-&gt;sp += - argc - 1;

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/192">

<div class="notes">Here are the changes needed.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

<b class="block">    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {</b>
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    <b>}</b>

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/193">

<div class="notes">The first change is the addition of an argument to CALLER_SETUP_ARG for whether it is safe to use a temporary array for the arguments. In this case, it is.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, <b>ALLOW_HEAP_ARGV</b>);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/194">

<div class="notes">If there was temporary array created to handle a large argument splat,</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(<b>calling-&gt;heap_argv</b>)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/195">

<div class="notes">then we get a pointer to the first element in the array.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        <b>argv = RARRAY_PTR(calling-&gt;heap_argv);</b>
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/196">

<div class="notes">This is instead of allocating space on the C stack, and copying the arguments from the VM stack to the C stack.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
<b class="block">      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);</b>
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/197">

<div class="notes">We need to decrement the stack pointer by 2, since the array is considered one argument.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        <b>cfp-&gt;sp -= 2;</b>
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/198">

<div class="notes">This is to match the stack pointer adjustment in the normal case. Failure to adjust the stack pointer correctly results in sp/bp mismatch errors or failing cfp consistency checks, both of which are time consuming to debug.|Unfortunately, this change did not fix the stack overflow issue for bmethods. That is because we have a similar issue later in the VM.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      <b>cfp-&gt;sp += - argc - 1;</b>
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/199">

<div class="notes">3 nested function calls after calling vm_call_bmethod_body,</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return <b>vm_call_bmethod_body(ec, calling, argv);</b>
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/200">

<div class="notes">the VM calls a function named invoke_iseq_block_from_c</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = argv[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, kw_splat, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/201">

<div class="notes">which also copies all arguments to the VM stack.</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
<b class="block">    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = argv[i];
    }</b>

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, kw_splat, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/202">

<div class="notes">First raising a SystemStackError if copying the arguments would overflow the stack.|If you remember a few slides ago, the code that called this function copied arguments from the VM stack to the C stack, and this copies the same arguments from the C stack back to the VM stack. This unnecessary copying is one reason bmethod calling is slower than calling normal ruby methods.</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...

    <b>CHECK_VM_STACK_OVERFLOW(cfp, argc);</b>
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = argv[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, kw_splat, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/203">

<div class="notes">I worked around this issue using the same approach used in the CALLER_SETUP_ARG code, by creating a temporary hidden Ruby array to store the arguments.</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...
<b class="block">    int flags = (kw_splat ? VM_CALL_KW_SPLAT : 0);
    VALUE *use_argv = (VALUE *)argv;
    VALUE av[2];

    if (UNLIKELY(argc &gt; VM_ARGC_STACK_MAX)) {
        use_argv = vm_argv_ruby_array(av, argv, &amp;flags, &amp;argc, kw_splat);
    }</b>

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = <b>use_argv</b>[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, <b>flags</b>, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/204">

<div class="notes">If the number of arguments provided is over the limit,</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...
    int flags = (kw_splat ? VM_CALL_KW_SPLAT : 0);
    VALUE *use_argv = (VALUE *)argv;
    VALUE av[2];

    if (UNLIKELY(<b>argc &gt; VM_ARGC_STACK_MAX</b>)) {
        use_argv = vm_argv_ruby_array(av, argv, &amp;flags, &amp;argc, kw_splat);
    }

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = use_argv[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, flags, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/205">

<div class="notes">we call a newly added vm_argv_ruby_array function to create a temporary Ruby array, copy the arguments from argv into it, and then return a pointer to the Ruby array.</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...
    int flags = (kw_splat ? VM_CALL_KW_SPLAT : 0);
    VALUE *use_argv = (VALUE *)argv;
    VALUE av[2];

    if (UNLIKELY(argc &gt; VM_ARGC_STACK_MAX)) {
        use_argv = <b>vm_argv_ruby_array</b>(av, argv, &amp;flags, &amp;argc, kw_splat);
    }

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = use_argv[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, flags, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/206">

<div class="notes">We actually always pass an array of two arguments in this case. The first argument is that temporary array. The second argument is always a keyword hash.</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...
    int flags = (kw_splat ? VM_CALL_KW_SPLAT : 0);
    VALUE *use_argv = (VALUE *)argv;
    <b>VALUE av[2];</b>

    if (UNLIKELY(argc &gt; VM_ARGC_STACK_MAX)) {
        use_argv = vm_argv_ruby_array(av, argv, &amp;flags, &amp;argc, kw_splat);
    }

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = use_argv[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, flags, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/207">

<div class="notes">If kw_splat is true, that means the last argument of the array is keyword arguments, so it is removed from the array and stored as a separate argument. If kw_splat is false, we add an empty hash for keyword arguments, so that Ruby will not treat a flagged keyword hash passed as a regular argument as a keyword splat.</div>
<pre class="sh_c" style="font-size: 30px; margin-top: 48px; margin-left: 20px;"><code>static inline VALUE
invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,
                         VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,
                         const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)
{
    // ...
    int flags = (<b>kw_splat</b> ? VM_CALL_KW_SPLAT : 0);
    VALUE *use_argv = (VALUE *)argv;
    VALUE av[2];

    if (UNLIKELY(argc &gt; VM_ARGC_STACK_MAX)) {
        use_argv = vm_argv_ruby_array(av, argv, &amp;flags, &amp;argc, kw_splat);
    }

    CHECK_VM_STACK_OVERFLOW(cfp, argc);
    vm_check_canary(ec, sp);
    cfp-&gt;sp = sp + argc;
    for (i=0; i&lt;argc; i++) {
        sp[i] = use_argv[i];
    }

    opt_pc = vm_yield_setup_args(ec, iseq, argc, sp, flags, passed_block_handler,
                                 (is_lambda ? arg_setup_method : arg_setup_block));

    // ...
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/208">

<div class="notes">With those changes, you can now call methods defined with define_method or define_singleton_method with large array splats. However, that was not the only case that previously failed, there were other cases that failed as well.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
define_singleton_method(:a) do |*ary|
  ary.length
end

a(*1380888.times)
# =&gt; 1380888
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/209">

<div class="notes">While splatting a large array starting working with normal method definition in Ruby 2.2,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/210">

<div class="notes">If you called the same method using send,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888

<b>send(:a, *1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/211">

<div class="notes">you got a SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888

send(:a, *1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/212">

<div class="notes">If you used Symbol#to_proc and called the resulting proc with a large array splat,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888

<b>:a.to_proc.(self, *1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/213">

<div class="notes">you got a SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888

:a.to_proc.(self, *1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/214">

<div class="notes">If you created a Method object for the method, and called that with a large array splat,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888

<b>method(:a).(*1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/215">

<div class="notes">you got a SystemStackError.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
# =&gt; 1380888

method(:a).(*1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/216">

<div class="notes">If you defined method_missing,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
<b class="block">def self.method_missing(method, *ary)
  ary.length
end</b>

a(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/217">

<div class="notes">then called a method that did not exist with a large array splat,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.method_missing(method, *ary)
  ary.length
end

<b>a(*1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/218">

<div class="notes">you got a SystemStackError. Additionally, passing a large number of arguments in a C extension using rb_yield_block also resulted in a SystemStackError. Those were the most important cases that needed to be handled where it could be useful to pass a large number of arguments.|There were also some cases where the method type only accepts 0 or 1 argument, where passing a large array splat resulted in a SystemStackError instead of an ArgumentError.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.method_missing(method, *ary)
  ary.length
end

a(*1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/219">

<div class="notes">If we go back to the normal method definition,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(*ary)
  ary.length
end

a(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/220">

<div class="notes">and change the argument splat,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(<b>*ary</b>)
  ary.length
end

a(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/221">

<div class="notes">to a regular argument,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(<b>ary</b>)
  ary.length
end

a(*1380888.times)
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/222">

<div class="notes">when calling the method with a large array splat</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(ary)
  ary.length
end

<b>a(*1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/223">

<div class="notes">It would be best to have an ArgumentError raised,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(ary)
  ary.length
end

a(*1380888.times)
# <b>ArgumentError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/224">

<div class="notes">but Ruby would raise a SystemStackError in that case.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
def self.a(ary)
  ary.length
end

a(*1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/225">

<div class="notes">Similarly, if you have a class that uses attr_reader</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
class A
  attr_reader :a
end
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/226">

<div class="notes">calling the method defined with a large array splat</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
class A
  attr_reader :a
end

<b>A.new.a(*1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/227">

<div class="notes">raises a SystemStackError instead of an ArgumentError. The same issue is true for attr_writer.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
class A
  attr_reader :a
end

A.new.a(*1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/228">

<div class="notes">If you create a Struct class,</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
A = Struct.new(:a)

</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/229">

<div class="notes">Calling the member reader method for an instance of the Struct with a large array splat</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
A = Struct.new(:a)

<b>A.new.a(*1380888.times)</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/230">

<div class="notes">raises a SystemStackError instead of an ArgumentError. The same issue is true for the member setter method.</div>
<pre class="sh_ruby" style="font-size: 64px; margin-top: 48px; margin-left: 220px;"><code>
A = Struct.new(:a)

A.new.a(*1380888.times)
# <b>SystemStackError</b>
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/231">

<div class="notes">Squashing this bug, both for the method types that could accept a large number of arguments, and to get the correct exception raised for method types that only accept 0 or 1 argument, took quite a long time.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 50px; left: 150px;">Squashing</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 270px; left: 450px;">the</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 270px; left: 200px;">Bug</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/232">

<div class="notes">One reason for this is this issue is not really a single bug, but an entire class of related bugs.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 50px; left: 150px;">Squashing</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 270px; left: 450px;">the</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 270px; left: 200px;">Bug<u style="text-decoration-color: #00005E;">s</u>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/233">

<div class="notes">Another reason is that fixing these bugs turned into a game of bug whack-a-mole, where fixing a single instance of this bug broke other test cases. I would fix those test cases, just to have something else break.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 230px; left: 140px;">Bug</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 430px; left: 150px;">Whack<span class="red">-</span>A<span class="red">-</span>Mole</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/234">

<div class="notes">One thing to be aware of is that almost no code in Ruby’s test suite passes a large array splat. So running the test suites that come with Ruby would be unlikely to catch issues with the changes I was making.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 150px; left: 150px;">Testing</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 335px; left: 320px;">Rare</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 480px; left: 150px;">Cases</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/235">

<div class="notes">To get a higher level of confidence that the bug fixes were actually working, I did most of my debugging by forcing temporary array usage for all method calls with splats, instead of the default behavior of only using a temporary array for splats of large arrays.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 350px; left: 150px;">Forcing</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 530px; left: 150px;">Temporary</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 710px; left: 150px;">Arrays</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/236">

<div class="notes">Eventually, I was able to get the entire test suite passing, fixing all cases I was aware of where passing a large array splat raised SystemStackError. However, just because all bugs have been fixed does not necessarily mean that the fixes should be committed.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 70px; left: 50px;">All</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 250px; left: 150px;">Bugs</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 450px; left: 250px;">Fixed<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/237">

<div class="notes">When deciding whether to commit anything, you need to have an understanding of the costs and benefits of committing, and you should feel that the benefits are worth the costs.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 100px; left: 150px;">Costs</h1>
<h1 class="red" style="font-size: 150px; position: absolute; top: 280px; left: 300px;">vs.</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 330px; left: 150px;">Benefits</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/238">

<div class="notes">In this case, the benefit is you can splat an array when calling any Ruby method, and you should get the expected behavior regardless of the size of the array. I think that is a significant benefit, but the actual need to pass a large array splat is rare, and it is almost always better to pass a large array of arguments as a normal argument, instead of splatting the array.|Additionally, as I showed early in this presentation, if you don’t fix this issue, it will be possible to remotely trigger a SystemStackError in some Ruby web applications.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 330px; left: 150px;">Benefits</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/239">

<div class="notes">There are significant costs associated with the fixes.</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 110px; left: 150px;">Costs</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/240">

<div class="notes">For one, the fixes are invasive, much more so than my initial attempt to fix the issue for cfunc methods.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 460px; right: 424px;">Invasive</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/241">

<div class="notes">For another, there is a minor slowdown associated with this change. With all of the work to improve Ruby’s performance, committing this patch can feel like a step backward.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 360px; left: 624px;">Minor</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 540px; left: 624px;">Slowdown</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/242">

<div class="notes">One reason for the slowdown is that extra checks were added. For every call to a method not written in Ruby, there are extra checks for whether a temporary array was used, in some cases even if the method call did not use a splat.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 120px; left: 124px;">Extra</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 300px; left: 124px;">Checks</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/243">

<div class="notes">The code added to handle arguments in temporary arrays also bloats the code. That can result additional instruction cache misses, because less of Ruby’s code may fit in the processor’s instruction cache.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 220px; left: 1224px;">Code</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 400px; left: 1224px;">Bloat</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/244">

<div class="notes">I thought it would be unlikely that committers would accept a minor slowdown to fix these corner cases. Thankfully, during my work fixing these bugs, I learned a lot about Ruby’s internals.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 180px; left: 624px;">Offsetting</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 360px; left: 624px;">Minor</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 540px; left: 624px;">Slowdown</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/245">

<div class="notes">With what I learned, I developed a series of patches to optimize calling in certain cases. My goal with this series of patches was to offset the minor slowdown introduced by the bug fixes.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 370px; left: 284px;">Optimizations</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/246">

<div class="notes">One of the optimizations was to bmethod calling. Here is the code for vm_call_bmethod again.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/247">

<div class="notes">One thing to notice is that this function always calls CALLER_SETUP_ARG.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    <b>CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);</b>
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/248">

<div class="notes">The reason it does this is so it can flatten the arguments into a C array, and pass a pointer to the first argument to vm_call_bmethod_body.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, <b>argv</b>);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/249">

<div class="notes">I determined that this call to CALLER_SETUP_ARG is not actually needed in the common case where the block for the bmethod is defined in Ruby. However, it is needed in other cases where the block for the bmethod is defined in C or was created by Symbol#to_proc.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    VALUE *argv;
    int argc;
    const struct rb_callinfo *ci = calling-&gt;ci;

    <b>CALLER_SETUP_ARG(cfp, calling, ci, ALLOW_HEAP_ARGV);</b>
    if (UNLIKELY(calling-&gt;heap_argv)) {
        argv = RARRAY_PTR(calling-&gt;heap_argv);
        cfp-&gt;sp -= 2;
    }
    else {
      argc = calling-&gt;argc;
      argv = ALLOCA_N(VALUE, argc);
      MEMCPY(argv, cfp-&gt;sp - argc, VALUE, argc);
      cfp-&gt;sp += - argc - 1;
    }

    return vm_call_bmethod_body(ec, calling, argv);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/250">

<div class="notes">So I decided to split bmethod call handling into two paths, one to handle the case where the block is defined in Ruby, and another for other blocks.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
    VALUE procv = cme-&gt;def-&gt;body.bmethod.proc;
    rb_proc_t *proc;
    GetProcPtr(procv, proc);
    const struct rb_block *block = &amp;proc-&gt;block;

    while (vm_block_type(block) == block_type_proc) {
        block = vm_proc_block(block-&gt;as.proc);
    }
    if (vm_block_type(block) == block_type_iseq) {
        CC_SET_FASTPATH(cc, vm_call_iseq_bmethod, TRUE);
        return vm_call_iseq_bmethod(ec, cfp, calling);
    }

    CC_SET_FASTPATH(cc, vm_call_noniseq_bmethod, TRUE);
    return vm_call_noniseq_bmethod(ec, cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/251">

<div class="notes">All of this code is necessary to determine whether the block was defined in Ruby.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

<b class="block">    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
    VALUE procv = cme-&gt;def-&gt;body.bmethod.proc;
    rb_proc_t *proc;
    GetProcPtr(procv, proc);
    const struct rb_block *block = &amp;proc-&gt;block;

    while (vm_block_type(block) == block_type_proc) {
        block = vm_proc_block(block-&gt;as.proc);
    }
    if (vm_block_type(block) == block_type_iseq) {</b>
        CC_SET_FASTPATH(cc, vm_call_iseq_bmethod, TRUE);
        return vm_call_iseq_bmethod(ec, cfp, calling);
    }

    CC_SET_FASTPATH(cc, vm_call_noniseq_bmethod, TRUE);
    return vm_call_noniseq_bmethod(ec, cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/252">

<div class="notes">If the block was defined in Ruby, we can call an optimized function that does not need to use CALLER_SETUP_ARG.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
    VALUE procv = cme-&gt;def-&gt;body.bmethod.proc;
    rb_proc_t *proc;
    GetProcPtr(procv, proc);
    const struct rb_block *block = &amp;proc-&gt;block;

    while (vm_block_type(block) == block_type_proc) {
        block = vm_proc_block(block-&gt;as.proc);
    }
    if (vm_block_type(block) == block_type_iseq) {
        CC_SET_FASTPATH(cc, vm_call_iseq_bmethod, TRUE);
        return <b>vm_call_iseq_bmethod(ec, cfp, calling)</b>;
    }

    CC_SET_FASTPATH(cc, vm_call_noniseq_bmethod, TRUE);
    return vm_call_noniseq_bmethod(ec, cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/253">

<div class="notes">If the block was not defined in Ruby, we call another function that uses CALLER_SETUP_ARG, which is similar to the previous implementation.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
    VALUE procv = cme-&gt;def-&gt;body.bmethod.proc;
    rb_proc_t *proc;
    GetProcPtr(procv, proc);
    const struct rb_block *block = &amp;proc-&gt;block;

    while (vm_block_type(block) == block_type_proc) {
        block = vm_proc_block(block-&gt;as.proc);
    }
    if (vm_block_type(block) == block_type_iseq) {
        CC_SET_FASTPATH(cc, vm_call_iseq_bmethod, TRUE);
        return vm_call_iseq_bmethod(ec, cfp, calling);
    }

    CC_SET_FASTPATH(cc, vm_call_noniseq_bmethod, TRUE);
    return <b>vm_call_noniseq_bmethod(ec, cfp, calling)</b>;
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/254">

<div class="notes">In either case, before calling the function, we update the call cache.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
    VALUE procv = cme-&gt;def-&gt;body.bmethod.proc;
    rb_proc_t *proc;
    GetProcPtr(procv, proc);
    const struct rb_block *block = &amp;proc-&gt;block;

    while (vm_block_type(block) == block_type_proc) {
        block = vm_proc_block(block-&gt;as.proc);
    }
    if (vm_block_type(block) == block_type_iseq) {
        <b>CC_SET_FASTPATH(cc, vm_call_iseq_bmethod, TRUE)</b>;
        return vm_call_iseq_bmethod(ec, cfp, calling);
    }

    <b>CC_SET_FASTPATH(cc, vm_call_noniseq_bmethod, TRUE)</b>;
    return vm_call_noniseq_bmethod(ec, cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/255">

<div class="notes">The reason we update the call cache is so future calls at the same callsite can jump directly to the optimized function, and skip all of this code.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_bmethod(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                struct rb_calling_info *calling)
{
<b class="block">    RB_DEBUG_COUNTER_INC(ccf_bmethod);

    const struct rb_callcache *cc = calling-&gt;cc;
    const rb_callable_method_entry_t *cme = vm_cc_cme(cc);
    VALUE procv = cme-&gt;def-&gt;body.bmethod.proc;
    rb_proc_t *proc;
    GetProcPtr(procv, proc);
    const struct rb_block *block = &amp;proc-&gt;block;

    while (vm_block_type(block) == block_type_proc) {
        block = vm_proc_block(block-&gt;as.proc);
    }
    if (vm_block_type(block) == block_type_iseq) {</b>
        CC_SET_FASTPATH(cc, vm_call_iseq_bmethod, TRUE);
        return vm_call_iseq_bmethod(ec, cfp, calling);
    }

    CC_SET_FASTPATH(cc, vm_call_noniseq_bmethod, TRUE);
    return vm_call_noniseq_bmethod(ec, cfp, calling);
}
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/256">

<div class="notes">I added some benchmarks</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/257">

<div class="notes">and found that these changes improved bmethod calling by 40% in simple cases, and up to 180% in keyword cases.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">bmethod:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 620px; left: 860px;">40-180<span class="blue">%</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/258">

<div class="notes">Another of the optimizations was to method missing calls. Here is the top of vm_call_method_missing_body before the bug fix and optimization.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_missing_body(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                            struct rb_calling_info *calling, const struct rb_callinfo *orig_ci,
                            enum method_missing_reason reason)
{
    RB_DEBUG_COUNTER_INC(ccf_method_missing);

    VALUE *argv = STACK_ADDR_FROM_TOP(calling-&gt;argc);
    unsigned int argc;

    CALLER_SETUP_ARG(reg_cfp, calling, orig_ci);
    argc = calling-&gt;argc + 1;

    unsigned int flag = VM_CALL_FCALL | VM_CALL_OPT_SEND |
                        (calling-&gt;kw_splat ? VM_CALL_KW_SPLAT : 0);
    calling-&gt;argc = argc;
    // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/259">

<div class="notes">I determined that the CALLER_SETUP_ARG function call here is unnecessary, as method_missing calls do not need to modify existing arguments, they just need to add an argument before those arguments.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_missing_body(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                            struct rb_calling_info *calling, const struct rb_callinfo *orig_ci,
                            enum method_missing_reason reason)
{
    RB_DEBUG_COUNTER_INC(ccf_method_missing);

    VALUE *argv = STACK_ADDR_FROM_TOP(calling-&gt;argc);
    unsigned int argc;

    <b>CALLER_SETUP_ARG(reg_cfp, calling, orig_ci);</b>
    argc = calling-&gt;argc + 1;

    unsigned int flag = VM_CALL_FCALL | VM_CALL_OPT_SEND |
                        (calling-&gt;kw_splat ? VM_CALL_KW_SPLAT : 0);
    calling-&gt;argc = argc;
    // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/260">

<div class="notes">So the call to CALLER_SETUP_ARG can be removed completely.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_missing_body(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                            struct rb_calling_info *calling, const struct rb_callinfo *orig_ci,
                            enum method_missing_reason reason)
{
    RB_DEBUG_COUNTER_INC(ccf_method_missing);

    VALUE *argv = STACK_ADDR_FROM_TOP(calling-&gt;argc);
    unsigned int argc;

    <b>                                            </b>
    argc = calling-&gt;argc + 1;

    unsigned int flag = VM_CALL_FCALL | VM_CALL_OPT_SEND |
                        (calling-&gt;kw_splat ? VM_CALL_KW_SPLAT : 0);
    calling-&gt;argc = argc;
    // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/261">

<div class="notes">However, you do need to fix the calling flags. The calling flags include information about whether the call includes an argument splat or keyword arguments. Since CALLER_SETUP_ARG was used previously, new calling flags were created.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_missing_body(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                            struct rb_calling_info *calling, const struct rb_callinfo *orig_ci,
                            enum method_missing_reason reason)
{
    RB_DEBUG_COUNTER_INC(ccf_method_missing);

    VALUE *argv = STACK_ADDR_FROM_TOP(calling-&gt;argc);
    unsigned int argc;

    
    argc = calling-&gt;argc + 1;

    unsigned int flag = VM_CALL_FCALL | VM_CALL_OPT_SEND |
                        <b>(calling-&gt;kw_splat ? VM_CALL_KW_SPLAT : 0)</b>;
    calling-&gt;argc = argc;
    // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/262">

<div class="notes">However, when removing the CALLER_SETUP_ARG function call, you can just copy the calling flags from the original method call that resulted in method_missing, and that fixes the issue.</div>
<pre class="sh_c" style="font-size: 32px; margin-top: 48px; margin-left: 20px;"><code>static VALUE
vm_call_method_missing_body(rb_execution_context_t *ec, rb_control_frame_t *cfp,
                            struct rb_calling_info *calling, const struct rb_callinfo *orig_ci,
                            enum method_missing_reason reason)
{
    RB_DEBUG_COUNTER_INC(ccf_method_missing);

    VALUE *argv = STACK_ADDR_FROM_TOP(calling-&gt;argc);
    unsigned int argc;

    
    argc = calling-&gt;argc + 1;

    unsigned int flag = VM_CALL_FCALL | VM_CALL_OPT_SEND |
                        <b>vm_ci_flag(orig_ci)</b>;
    calling-&gt;argc = argc;
    // ...
</code></pre>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/263">

<div class="notes">That simple change improved method missing calls by 10% for simple calls, and up to 110% for calls involving keyword arguments.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">bmethod:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 620px; left: 860px;">40-180<span class="blue">%</span>
</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 720px; right: 1100px;">method_missing:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 720px; left: 860px;">10-110<span class="blue">%</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/264">

<div class="notes">I made a similar change for calls to symbol procs, which are procs created by Symbol#to_proc. That improved performance 5% for simple calls and up to 100% for keyword argument calls.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">bmethod:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 620px; left: 860px;">40-180<span class="blue">%</span>
</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 720px; right: 1100px;">method_missing:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 720px; left: 860px;">10-110<span class="blue">%</span>
</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 820px; right: 1100px;">symproc:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 820px; left: 860px;">5-100<span class="blue">%</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/265">

<div class="notes">I also made a similar change to method calls using send, which improved performance 5% for simple calls and up to 115% for keyword argument calls.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">bmethod:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 620px; left: 860px;">40-180<span class="blue">%</span>
</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 720px; right: 1100px;">method_missing:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 720px; left: 860px;">10-110<span class="blue">%</span>
</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 820px; right: 1100px;">symproc:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 820px; left: 860px;">5-100<span class="blue">%</span>
</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 920px; right: 1100px;">send:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 920px; left: 860px;">5-115<span class="blue">%</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/266">

<div class="notes">To see the overall effect of the bug fixes combined with the performance optimizations, I used yjit-bench. yjit-bench was developed by Shopify to test yjit performance, but is also useful as a set of general benchmarks. It contains 33 separate benchmarks.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">yjit-bench</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/267">

<div class="notes">Results showed that performance was about the same in 12 benchmarks.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">yjit-bench</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 720px; right: 1100px;">same:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 720px; left: 860px;">12</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/268">

<div class="notes">8 benchmarks got slower in spite of the optimizations, up to 3% slower in the worst case.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">yjit-bench</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 720px; right: 1100px;">same:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 720px; left: 860px;">12</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 820px; right: 1100px;">slower:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 820px; left: 860px;">8 (1-3<span class="blue">%</span>)</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/269">

<div class="notes">However, 13 benchmarks got faster, up to 10% faster, because the performance increase from the optimizations was higher than the performance decrease from the bug fixes.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 10px; left: 24px;">Method</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 190px; left: 124px;">Calling</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 350px; left: 360px;">Benchmarks</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 620px; right: 1100px;">yjit-bench</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 720px; right: 1100px;">same:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 720px; left: 860px;">12</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 820px; right: 1100px;">slower:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 820px; left: 860px;">8 (1-3<span class="blue">%</span>)</h1>
<h1 class="blue" style="font-size: 100px; position: absolute; top: 920px; right: 1100px;">faster:</h1>
<h1 class="red" style="font-size: 100px; position: absolute; top: 920px; left: 860px;">13 (1-10<span class="blue">%</span>)</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/270">

<div class="notes">After finishing those method calling optimizations, I brought the issue up as a topic in April during the monthly developer meeting. This way other committers could provide feedback, and matz could decide whether the benefits were worth the costs. There was some concern over the performance and the invasiveness of the changes.</div>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 60px; left: 324px;">Developer</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 240px; left: 454px;">Meeting</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/271">

<div class="notes">However, I ultimately received approval to merge the changes. There was one remaining issue.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 360px; left: 110px;">Merge</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 520px; left: 424px;">Approval<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/272">

<div class="notes">I mentioned earlier that I fixed all bugs I was aware of, but there should be a caveat added. In truth, I fixed all bugs in the virtual machine,</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 70px; left: 50px;">All</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 250px; left: 150px;">Bugs</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 450px; left: 250px;">Fixed<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/273">

<div class="notes">but it turns out that yjit did not support the change I was making. The yjit tests on arm64 generally failed, with occasional failures on amd64. I discussed the issue with the yjit team, and thankfully they were able to fix the yjit issues. After the yjit issues were fixed, and one last round of testing,</div>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 70px; left: 50px;">All</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 250px; left: 150px;">Bugs</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 450px; left: 250px;">Fixed<span class="red">!</span>
</h1>
<h1 class="red" style="font-size: 180px; position: absolute; top: 655px; left: 152px;">(except <span class="blue">yjit</span>)</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/274">

<div class="notes">I was able to merge the changes.</div>
<h1 class="blue" style="font-size: 420px; position: absolute; top: 560px; left: 124px;">Merged<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/275">

<div class="notes">Ensuring that the second oldest bug, in all of its incarnations, will finally be fixed in Ruby 3.3.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 740px; left: 74px;">Fixed<span class="red">!!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/276">

<div class="notes">At least, that’s the current plan. While the fix has been merged, there is a definite possibility it will be reverted in the future if the additional complexity becomes problematic to maintain, or if it starts becoming a larger performance burden as Ruby itself becomes faster.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 740px; left: 74px;">Fixed<span class="red"> (for now)</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/277">

<div class="notes">Here are the lessons I learned from my experience fixing these bugs.</div>
<h1 class="blue" style="font-size: 210px; position: absolute; top: 232px; left: 450px;">Lessons</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 340px; left: 350px;">Learned</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/278">

<div class="notes">First, just because a bug is old, does not mean it cannot be fixed. Splatting a very large array in a method call has been a problem since Ruby supported splatting arrays, and this issue was known for over a decade before I started work on fixing it. In general, it just takes one person with the determination to fix the bug.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 24px; left: 150px;">Old Bugs</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 212px; left: 220px;">Can Be Fixed</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/279">

<div class="notes">Second, fixing an old bug is often a learning process that teaches you useful things you probably would not have learned otherwise. Without the experience I gained from fixing these bugs, I would not have been able to implement the performance optimizations I discussed.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 24px; left: 150px;">Old Bugs</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 222px; left: 350px;">Teach</h1>
<h1 class="red" style="font-size: 250px; position: absolute; top: 410px; left: 370px;">New <span class="blue">Tricks</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/280">

<div class="notes">Finally, do not worry if you cannot fix any Ruby bug perfectly by yourself. As this issue showed, other committers will likely be available to help improve your bug fixes so they can be committed.</div>
<h1 class="red" style="font-size: 250px; position: absolute; top: 360px; left: 550px;">Help Is</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 560px; left: 350px;">Available<span class="red">!</span>
</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/281">

<div class="notes">Ruby currently has over 50 open bugs in the bug tracker that are over 5 years old, just waiting for you to fix. We look forward to your contibutions!</div>
<h1 class="red" style="font-size: 650px; position: absolute; top: 222px; left: 50px;">50+</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 300px; left: 1100px;">Old</h1>
<h1 class="blue" style="font-size: 250px; position: absolute; top: 600px; left: 1100px;">Bugs</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/282">

<div class="notes">I hope you had fun learning about Ruby’s second oldest bug, and how we fixed it in Ruby 3.3.</div>
<h1 class="red" style="font-size: 220px; position: absolute; top: 90px; left: 154px;">The</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 220px; left: 54px;">Second</h1>
<h1 class="blue" style="font-size: 220px; position: absolute; top: 393px; left: 82px;">Oldest</h1>
<h1 class="red" style="font-size: 220px; position: absolute; top: 560px; left: 154px;">Bug</h1>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/283">

<div class="notes">If you enjoyed this presentation, and want to read more of my thoughts on Ruby programming, please consider picking up a copy of Polished Ruby Programming.</div>

<p><img src="./file/polished-ruby-programming-cover.png" style="position: absolute; top: 20px; left: 581px; height: 1031px; width: 822px;"></p>
</div>
</div>
</body></html><html><body>
<div id="slides/slides" class="slide " data-transition="none">
<div class="content " ref="slides/slides/284">

<div class="notes">That concludes my presentation. I would like to thank all of you for listening to me.</div>
<h1 class="blue" style="font-size: 300px; position: absolute; top: 432px; left: 150px;">Thank You<span class="red">!</span>
</h1>
</div>
</div>
</body></html>
</div>

</body>
</html>
